"use strict";exports.id=413,exports.ids=[413],exports.modules={4791:(e,t,r)=>{r.d(t,{$4:()=>SignIdentity,ed:()=>AnonymousIdentity});var o=r(7668),i=r(3482),n=r(1947),s=r(253);let SignIdentity=class SignIdentity{getPrincipal(){return this._principal||(this._principal=o.R.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()))),this._principal}async transformRequest(e){let{body:t,...r}=e,o=(0,i.vH)(t);return{...r,body:{content:t,sender_pubkey:this.getPublicKey().toDer(),sender_sig:await this.sign((0,n.eV)(s.Wf,o))}}}};let AnonymousIdentity=class AnonymousIdentity{getPrincipal(){return o.R.anonymous()}async transformRequest(e){return{...e,body:{content:e.body}}}}},253:(e,t,r)=>{r.d(t,{Nz:()=>i,Wf:()=>o,d8:()=>n});let o=new TextEncoder().encode("\nic-request"),i=new TextEncoder().encode("\vic-response"),n=new TextEncoder().encode("\x1aic-request-auth-delegation")},3472:(e,t,r)=>{r.d(t,{BM:()=>n,eZ:()=>unwrapDER,nt:()=>wrapDER});var o=r(5610),i=r(3416);let encodeLenBytes=e=>{if(e<=127)return 1;if(e<=255)return 2;if(e<=65535)return 3;if(e<=16777215)return 4;throw o.pd.fromCode(new o.Hv("Length too long (> 4 bytes)"))},encodeLen=(e,t,r)=>{if(r<=127)return e[t]=r,1;if(r<=255)return e[t]=129,e[t+1]=r,2;if(r<=65535)return e[t]=130,e[t+1]=r>>8,e[t+2]=r,3;if(r<=16777215)return e[t]=131,e[t+1]=r>>16,e[t+2]=r>>8,e[t+3]=r,4;throw o.pd.fromCode(new o.Hv("Length too long (> 4 bytes)"))},decodeLenBytes=(e,t)=>{if(e[t]<128)return 1;if(128===e[t])throw o.pd.fromCode(new o.mx("Invalid length 0"));if(129===e[t])return 2;if(130===e[t])return 3;if(131===e[t])return 4;throw o.pd.fromCode(new o.mx("Length too long (> 4 bytes)"))},decodeLen=(e,t)=>{let r=decodeLenBytes(e,t);if(1===r)return e[t];if(2===r)return e[t+1];if(3===r)return(e[t+1]<<8)+e[t+2];if(4===r)return(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];throw o.pd.fromCode(new o.mx("Length too long (> 4 bytes)"))};Uint8Array.from([48,12,6,10,43,6,1,4,1,131,184,67,1,1]);let n=Uint8Array.from([48,5,6,3,43,101,112]);function wrapDER(e,t){let r=2+encodeLenBytes(e.byteLength+1),o=t.byteLength+r+e.byteLength,i=0,n=new Uint8Array(1+encodeLenBytes(o)+o);return n[i++]=48,i+=encodeLen(n,i,o),n.set(t,i),i+=t.byteLength,n[i++]=3,i+=encodeLen(n,i,e.byteLength+1),n[i++]=0,n.set(new Uint8Array(e),i),n}Uint8Array.from([48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,10]),Uint8Array.from([48,29,6,13,43,6,1,4,1,130,220,124,5,3,1,2,1,6,12,43,6,1,4,1,130,220,124,5,3,2,1]);let unwrapDER=(e,t)=>{let r=0,expect=(e,t)=>{if(n[r++]!==e)throw o.pd.fromCode(new o.mx(`Expected ${t} at offset ${r}`))},n=new Uint8Array(e);if(expect(48,"sequence"),r+=decodeLenBytes(n,r),!(0,i.mK)(n.slice(r,r+t.byteLength),t))throw o.pd.fromCode(new o.mx("Not the expected OID."));r+=t.byteLength,expect(3,"bit string");let s=decodeLen(n,r)-1;r+=decodeLenBytes(n,r),expect(0,"0 padding");let a=n.slice(r);if(s!==a.length)throw o.pd.fromCode(new o.VV(s,a.length));return a}},5610:(e,t,r)=>{r.d(t,{$n:()=>HashTreeDecodeErrorCode,Bp:()=>MissingSignatureErrorCode,Cq:()=>DerPrefixMismatchErrorCode,Ds:()=>ExpiryJsonDeserializeErrorCode,Ej:()=>ExternalError,GU:()=>CborDecodeErrorCode,Hv:()=>DerEncodeErrorCode,J7:()=>RejectError,JU:()=>MalformedPublicKeyErrorCode,K1:()=>CertificateHasTooManyDelegationsErrorCode,Ko:()=>UnknownError,Oy:()=>InvalidReadStateRequestErrorCode,PG:()=>MissingRootKeyErrorCode,PK:()=>HttpErrorCode,PS:()=>TransportError,Q7:()=>QuerySignatureVerificationFailedErrorCode,Re:()=>DerKeyLengthMismatchErrorCode,SZ:()=>LookupErrorCode,UY:()=>MissingCanisterIdErrorCode,VV:()=>DerDecodeLengthMismatchErrorCode,Vp:()=>TrustError,XQ:()=>CertificateVerificationErrorCode,Ys:()=>MalformedLookupFoundValueErrorCode,Zf:()=>n,_S:()=>IdentityInvalidErrorCode,bL:()=>MalformedSignatureErrorCode,bn:()=>HashValueErrorCode,cG:()=>RequestStatusDoneNoReplyErrorCode,dw:()=>CertifiedRejectErrorCode,e$:()=>AgentError,gY:()=>UncertifiedRejectErrorCode,hM:()=>UncertifiedRejectUpdateErrorCode,hu:()=>UnexpectedErrorCode,il:()=>ProtocolError,k6:()=>IngressExpiryInvalidErrorCode,l:()=>HttpV3ApiNotSupportedErrorCode,l3:()=>CertificateNotAuthorizedErrorCode,mx:()=>DerDecodeErrorCode,n6:()=>MissingLookupValueErrorCode,pX:()=>HttpDefaultFetchErrorCode,pd:()=>InputError,pi:()=>HttpFetchErrorCode,rY:()=>CertificateTimeErrorCode,uo:()=>TimeoutWaitingForResponseErrorCode,wb:()=>CreateHttpAgentErrorCode,wq:()=>CertificateOutdatedErrorCode,zH:()=>CborEncodeErrorCode});var o,i=r(1947);!function(e){e.Trust="Trust",e.Protocol="Protocol",e.Reject="Reject",e.Transport="Transport",e.External="External",e.Limit="Limit",e.Input="Input",e.Unknown="Unknown"}(o||(o={}));let ErrorCode=class ErrorCode{constructor(e=!1){this.isCertified=e}toString(){let e=this.toErrorMessage();return this.requestContext&&(e+=`
Request context:
  Request ID (hex): ${this.requestContext.requestId?(0,i.ci)(this.requestContext.requestId):"undefined"}
  Sender pubkey (hex): ${(0,i.ci)(this.requestContext.senderPubKey)}
  Sender signature (hex): ${(0,i.ci)(this.requestContext.senderSignature)}
  Ingress expiry: ${this.requestContext.ingressExpiry.toString()}`),this.callContext&&(e+=`
Call context:
  Canister ID: ${this.callContext.canisterId.toText()}
  Method name: ${this.callContext.methodName}
  HTTP details: ${JSON.stringify(this.callContext.httpDetails,null,2)}`),e}};let AgentError=class AgentError extends Error{get code(){return this.cause.code}set code(e){this.cause.code=e}get kind(){return this.cause.kind}set kind(e){this.cause.kind=e}get isCertified(){return this.code.isCertified}constructor(e,t){super(e.toString()),this.name="AgentError",this.cause={code:e,kind:t},Object.setPrototypeOf(this,AgentError.prototype)}hasCode(e){return this.code instanceof e}toString(){return`${this.name} (${this.kind}): ${this.message}`}};let ErrorKind=class ErrorKind extends AgentError{static fromCode(e){return new this(e)}};let TrustError=class TrustError extends ErrorKind{constructor(e){super(e,o.Trust),this.name="TrustError",Object.setPrototypeOf(this,TrustError.prototype)}};let ProtocolError=class ProtocolError extends ErrorKind{constructor(e){super(e,o.Protocol),this.name="ProtocolError",Object.setPrototypeOf(this,ProtocolError.prototype)}};let RejectError=class RejectError extends ErrorKind{constructor(e){super(e,o.Reject),this.name="RejectError",Object.setPrototypeOf(this,RejectError.prototype)}};let TransportError=class TransportError extends ErrorKind{constructor(e){super(e,o.Transport),this.name="TransportError",Object.setPrototypeOf(this,TransportError.prototype)}};let ExternalError=class ExternalError extends ErrorKind{constructor(e){super(e,o.External),this.name="ExternalError",Object.setPrototypeOf(this,ExternalError.prototype)}};let InputError=class InputError extends ErrorKind{constructor(e){super(e,o.Input),this.name="InputError",Object.setPrototypeOf(this,InputError.prototype)}};let UnknownError=class UnknownError extends ErrorKind{constructor(e){super(e,o.Unknown),this.name="UnknownError",Object.setPrototypeOf(this,UnknownError.prototype)}};let CertificateVerificationErrorCode=class CertificateVerificationErrorCode extends ErrorCode{constructor(e,t){super(),this.reason=e,this.error=t,this.name="CertificateVerificationErrorCode",Object.setPrototypeOf(this,CertificateVerificationErrorCode.prototype)}toErrorMessage(){let e=this.reason;return this.error&&(e+=`: ${formatUnknownError(this.error)}`),`Certificate verification error: "${e}"`}};let CertificateTimeErrorCode=class CertificateTimeErrorCode extends ErrorCode{constructor(e,t,r,o,i){super(),this.maxAgeInMinutes=e,this.certificateTime=t,this.currentTime=r,this.timeDiffMsecs=o,this.ageType=i,this.name="CertificateTimeErrorCode",Object.setPrototypeOf(this,CertificateTimeErrorCode.prototype)}toErrorMessage(){return`Certificate is signed more than ${this.maxAgeInMinutes} minutes in the ${this.ageType}. Certificate time: ${this.certificateTime.toISOString()} Current time: ${this.currentTime.toISOString()} Clock drift: ${this.timeDiffMsecs}ms`}};let CertificateHasTooManyDelegationsErrorCode=class CertificateHasTooManyDelegationsErrorCode extends ErrorCode{constructor(){super(),this.name="CertificateHasTooManyDelegationsErrorCode",Object.setPrototypeOf(this,CertificateHasTooManyDelegationsErrorCode.prototype)}toErrorMessage(){return"Certificate has too many delegations"}};let CertificateNotAuthorizedErrorCode=class CertificateNotAuthorizedErrorCode extends ErrorCode{constructor(e,t){super(),this.canisterId=e,this.subnetId=t,this.name="CertificateNotAuthorizedErrorCode",Object.setPrototypeOf(this,CertificateNotAuthorizedErrorCode.prototype)}toErrorMessage(){return`The certificate contains a delegation that does not include the canister ${this.canisterId.toText()} in the canister_ranges field. Subnet ID: ${this.subnetId.toText()}`}};let LookupErrorCode=class LookupErrorCode extends ErrorCode{constructor(e,t){super(),this.message=e,this.lookupStatus=t,this.name="LookupErrorCode",Object.setPrototypeOf(this,LookupErrorCode.prototype)}toErrorMessage(){return`${this.message}. Lookup status: ${this.lookupStatus}`}};let MalformedLookupFoundValueErrorCode=class MalformedLookupFoundValueErrorCode extends ErrorCode{constructor(e){super(),this.message=e,this.name="MalformedLookupFoundValueErrorCode",Object.setPrototypeOf(this,MalformedLookupFoundValueErrorCode.prototype)}toErrorMessage(){return this.message}};let MissingLookupValueErrorCode=class MissingLookupValueErrorCode extends ErrorCode{constructor(e){super(),this.message=e,this.name="MissingLookupValueErrorCode",Object.setPrototypeOf(this,MissingLookupValueErrorCode.prototype)}toErrorMessage(){return this.message}};let DerKeyLengthMismatchErrorCode=class DerKeyLengthMismatchErrorCode extends ErrorCode{constructor(e,t){super(),this.expectedLength=e,this.actualLength=t,this.name="DerKeyLengthMismatchErrorCode",Object.setPrototypeOf(this,DerKeyLengthMismatchErrorCode.prototype)}toErrorMessage(){return`BLS DER-encoded public key must be ${this.expectedLength} bytes long, but is ${this.actualLength} bytes long`}};let DerPrefixMismatchErrorCode=class DerPrefixMismatchErrorCode extends ErrorCode{constructor(e,t){super(),this.expectedPrefix=e,this.actualPrefix=t,this.name="DerPrefixMismatchErrorCode",Object.setPrototypeOf(this,DerPrefixMismatchErrorCode.prototype)}toErrorMessage(){return`BLS DER-encoded public key is invalid. Expected the following prefix: ${(0,i.ci)(this.expectedPrefix)}, but got ${(0,i.ci)(this.actualPrefix)}`}};let DerDecodeLengthMismatchErrorCode=class DerDecodeLengthMismatchErrorCode extends ErrorCode{constructor(e,t){super(),this.expectedLength=e,this.actualLength=t,this.name="DerDecodeLengthMismatchErrorCode",Object.setPrototypeOf(this,DerDecodeLengthMismatchErrorCode.prototype)}toErrorMessage(){return`DER payload mismatch: Expected length ${this.expectedLength}, actual length: ${this.actualLength}`}};let DerDecodeErrorCode=class DerDecodeErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="DerDecodeErrorCode",Object.setPrototypeOf(this,DerDecodeErrorCode.prototype)}toErrorMessage(){return`Failed to decode DER: ${this.error}`}};let DerEncodeErrorCode=class DerEncodeErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="DerEncodeErrorCode",Object.setPrototypeOf(this,DerEncodeErrorCode.prototype)}toErrorMessage(){return`Failed to encode DER: ${this.error}`}};let CborDecodeErrorCode=class CborDecodeErrorCode extends ErrorCode{constructor(e,t){super(),this.error=e,this.input=t,this.name="CborDecodeErrorCode",Object.setPrototypeOf(this,CborDecodeErrorCode.prototype)}toErrorMessage(){return`Failed to decode CBOR: ${formatUnknownError(this.error)}, input: ${(0,i.ci)(this.input)}`}};let CborEncodeErrorCode=class CborEncodeErrorCode extends ErrorCode{constructor(e,t){super(),this.error=e,this.value=t,this.name="CborEncodeErrorCode",Object.setPrototypeOf(this,CborEncodeErrorCode.prototype)}toErrorMessage(){return`Failed to encode CBOR: ${formatUnknownError(this.error)}, input: ${this.value}`}};let TimeoutWaitingForResponseErrorCode=class TimeoutWaitingForResponseErrorCode extends ErrorCode{constructor(e,t,r){super(),this.message=e,this.requestId=t,this.status=r,this.name="TimeoutWaitingForResponseErrorCode",Object.setPrototypeOf(this,TimeoutWaitingForResponseErrorCode.prototype)}toErrorMessage(){let e=`${this.message}
`;return this.requestId&&(e+=`  Request ID: ${(0,i.ci)(this.requestId)}
`),this.status&&(e+=`  Request status: ${this.status}
`),e}};let CertificateOutdatedErrorCode=class CertificateOutdatedErrorCode extends ErrorCode{constructor(e,t,r){super(),this.maxIngressExpiryInMinutes=e,this.requestId=t,this.retryTimes=r,this.name="CertificateOutdatedErrorCode",Object.setPrototypeOf(this,CertificateOutdatedErrorCode.prototype)}toErrorMessage(){let e=`Certificate is stale (over ${this.maxIngressExpiryInMinutes} minutes). Is the computer's clock synchronized?
  Request ID: ${(0,i.ci)(this.requestId)}
`;return void 0!==this.retryTimes&&(e+=`  Retried ${this.retryTimes} times.`),e}};let CertifiedRejectErrorCode=class CertifiedRejectErrorCode extends ErrorCode{constructor(e,t,r,o){super(!0),this.requestId=e,this.rejectCode=t,this.rejectMessage=r,this.rejectErrorCode=o,this.name="CertifiedRejectErrorCode",Object.setPrototypeOf(this,CertifiedRejectErrorCode.prototype)}toErrorMessage(){return`The replica returned a rejection error:
  Request ID: ${(0,i.ci)(this.requestId)}
  Reject code: ${this.rejectCode}
  Reject text: ${this.rejectMessage}
  Error code: ${this.rejectErrorCode}
`}};let UncertifiedRejectErrorCode=class UncertifiedRejectErrorCode extends ErrorCode{constructor(e,t,r,o,i){super(),this.requestId=e,this.rejectCode=t,this.rejectMessage=r,this.rejectErrorCode=o,this.signatures=i,this.name="UncertifiedRejectErrorCode",Object.setPrototypeOf(this,UncertifiedRejectErrorCode.prototype)}toErrorMessage(){return`The replica returned a rejection error:
  Request ID: ${(0,i.ci)(this.requestId)}
  Reject code: ${this.rejectCode}
  Reject text: ${this.rejectMessage}
  Error code: ${this.rejectErrorCode}
`}};let UncertifiedRejectUpdateErrorCode=class UncertifiedRejectUpdateErrorCode extends ErrorCode{constructor(e,t,r,o){super(),this.requestId=e,this.rejectCode=t,this.rejectMessage=r,this.rejectErrorCode=o,this.name="UncertifiedRejectUpdateErrorCode",Object.setPrototypeOf(this,UncertifiedRejectUpdateErrorCode.prototype)}toErrorMessage(){return`The replica returned a rejection error:
  Request ID: ${(0,i.ci)(this.requestId)}
  Reject code: ${this.rejectCode}
  Reject text: ${this.rejectMessage}
  Error code: ${this.rejectErrorCode}
`}};let RequestStatusDoneNoReplyErrorCode=class RequestStatusDoneNoReplyErrorCode extends ErrorCode{constructor(e){super(),this.requestId=e,this.name="RequestStatusDoneNoReplyErrorCode",Object.setPrototypeOf(this,RequestStatusDoneNoReplyErrorCode.prototype)}toErrorMessage(){return`Call was marked as done but we never saw the reply:
  Request ID: ${(0,i.ci)(this.requestId)}
`}};let MissingRootKeyErrorCode=class MissingRootKeyErrorCode extends ErrorCode{constructor(e){super(),this.shouldFetchRootKey=e,this.name="MissingRootKeyErrorCode",Object.setPrototypeOf(this,MissingRootKeyErrorCode.prototype)}toErrorMessage(){return void 0===this.shouldFetchRootKey?"Agent is missing root key":`Agent is missing root key and the shouldFetchRootKey value is set to ${this.shouldFetchRootKey}. The root key should only be unknown if you are in local development. Otherwise you should avoid fetching and use the default IC Root Key or the known root key of your environment.`}};let HashValueErrorCode=class HashValueErrorCode extends ErrorCode{constructor(e){super(),this.value=e,this.name="HashValueErrorCode",Object.setPrototypeOf(this,HashValueErrorCode.prototype)}toErrorMessage(){return`Attempt to hash a value of unsupported type: ${this.value}`}};let HttpDefaultFetchErrorCode=class HttpDefaultFetchErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="HttpDefaultFetchErrorCode",Object.setPrototypeOf(this,HttpDefaultFetchErrorCode.prototype)}toErrorMessage(){return this.error}};let IdentityInvalidErrorCode=class IdentityInvalidErrorCode extends ErrorCode{constructor(){super(),this.name="IdentityInvalidErrorCode",Object.setPrototypeOf(this,IdentityInvalidErrorCode.prototype)}toErrorMessage(){return"This identity has expired due this application's security policy. Please refresh your authentication."}};let IngressExpiryInvalidErrorCode=class IngressExpiryInvalidErrorCode extends ErrorCode{constructor(e,t){super(),this.message=e,this.providedIngressExpiryInMinutes=t,this.name="IngressExpiryInvalidErrorCode",Object.setPrototypeOf(this,IngressExpiryInvalidErrorCode.prototype)}toErrorMessage(){return`${this.message}. Provided ingress expiry time is ${this.providedIngressExpiryInMinutes} minutes.`}};let CreateHttpAgentErrorCode=class CreateHttpAgentErrorCode extends ErrorCode{constructor(){super(),this.name="CreateHttpAgentErrorCode",Object.setPrototypeOf(this,CreateHttpAgentErrorCode.prototype)}toErrorMessage(){return"Failed to create agent from provided agent"}};let MalformedSignatureErrorCode=class MalformedSignatureErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="MalformedSignatureErrorCode",Object.setPrototypeOf(this,MalformedSignatureErrorCode.prototype)}toErrorMessage(){return`Query response contained a malformed signature: ${this.error}`}};let MissingSignatureErrorCode=class MissingSignatureErrorCode extends ErrorCode{constructor(){super(),this.name="MissingSignatureErrorCode",Object.setPrototypeOf(this,MissingSignatureErrorCode.prototype)}toErrorMessage(){return"Query response did not contain any node signatures"}};let MalformedPublicKeyErrorCode=class MalformedPublicKeyErrorCode extends ErrorCode{constructor(){super(),this.name="MalformedPublicKeyErrorCode",Object.setPrototypeOf(this,MalformedPublicKeyErrorCode.prototype)}toErrorMessage(){return"Read state response contained a malformed public key"}};let QuerySignatureVerificationFailedErrorCode=class QuerySignatureVerificationFailedErrorCode extends ErrorCode{constructor(e){super(),this.nodeId=e,this.name="QuerySignatureVerificationFailedErrorCode",Object.setPrototypeOf(this,QuerySignatureVerificationFailedErrorCode.prototype)}toErrorMessage(){return`Query signature verification failed. Node ID: ${this.nodeId}`}};let UnexpectedErrorCode=class UnexpectedErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="UnexpectedErrorCode",Object.setPrototypeOf(this,UnexpectedErrorCode.prototype)}toErrorMessage(){return`Unexpected error: ${formatUnknownError(this.error)}`}};let HashTreeDecodeErrorCode=class HashTreeDecodeErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="HashTreeDecodeErrorCode",Object.setPrototypeOf(this,HashTreeDecodeErrorCode.prototype)}toErrorMessage(){return`Failed to decode certificate: ${this.error}`}};let HttpErrorCode=class HttpErrorCode extends ErrorCode{constructor(e,t,r,o){super(),this.status=e,this.statusText=t,this.headers=r,this.bodyText=o,this.name="HttpErrorCode",Object.setPrototypeOf(this,HttpErrorCode.prototype)}toErrorMessage(){let e=`HTTP request failed:
  Status: ${this.status} (${this.statusText})
  Headers: ${JSON.stringify(this.headers)}
`;return this.bodyText&&(e+=`  Body: ${this.bodyText}
`),e}};let HttpV3ApiNotSupportedErrorCode=class HttpV3ApiNotSupportedErrorCode extends ErrorCode{constructor(){super(),this.name="HttpV3ApiNotSupportedErrorCode",Object.setPrototypeOf(this,HttpV3ApiNotSupportedErrorCode.prototype)}toErrorMessage(){return"HTTP request failed: v3 API is not supported"}};let HttpFetchErrorCode=class HttpFetchErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="HttpFetchErrorCode",Object.setPrototypeOf(this,HttpFetchErrorCode.prototype)}toErrorMessage(){return`Failed to fetch HTTP request: ${formatUnknownError(this.error)}`}};let MissingCanisterIdErrorCode=class MissingCanisterIdErrorCode extends ErrorCode{constructor(e){super(),this.receivedCanisterId=e,this.name="MissingCanisterIdErrorCode",Object.setPrototypeOf(this,MissingCanisterIdErrorCode.prototype)}toErrorMessage(){return`Canister ID is required, but received ${typeof this.receivedCanisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`}};let InvalidReadStateRequestErrorCode=class InvalidReadStateRequestErrorCode extends ErrorCode{constructor(e){super(),this.request=e,this.name="InvalidReadStateRequestErrorCode",Object.setPrototypeOf(this,InvalidReadStateRequestErrorCode.prototype)}toErrorMessage(){return`Invalid read state request: ${this.request}`}};let ExpiryJsonDeserializeErrorCode=class ExpiryJsonDeserializeErrorCode extends ErrorCode{constructor(e){super(),this.error=e,this.name="ExpiryJsonDeserializeErrorCode",Object.setPrototypeOf(this,ExpiryJsonDeserializeErrorCode.prototype)}toErrorMessage(){return`Failed to deserialize expiry: ${this.error}`}};function formatUnknownError(e){if(e instanceof Error)return e.stack??e.message;try{return JSON.stringify(e)}catch{return String(e)}}let n=Error("unreachable")},3482:(e,t,r)=>{r.d(t,{E$:()=>hashOfMap,vH:()=>requestIdOf});var o=r(648),i=r(2484),n=r(5610),s=r(3416),a=r(1947),d=r(7742);function hashValue(e){if("string"==typeof e)return hashString(e);if("number"==typeof e)return(0,d.JQ)((0,o.dZ)(e));if(e instanceof Uint8Array||ArrayBuffer.isView(e))return(0,d.JQ)((0,s.ZP)(e));if(Array.isArray(e)){let t=e.map(hashValue);return(0,d.JQ)((0,a.eV)(...t))}if(e&&"object"==typeof e&&e._isPrincipal)return(0,d.JQ)(e.toUint8Array());if("object"==typeof e&&null!==e&&"function"==typeof e.toHash)return hashValue(e.toHash());if("object"==typeof e)return hashOfMap(e);else if("bigint"==typeof e)return(0,d.JQ)((0,o.dZ)(e));throw n.pd.fromCode(new n.bn(e))}let hashString=e=>{let t=new TextEncoder().encode(e);return(0,d.JQ)(t)};function requestIdOf(e){return hashOfMap(e)}function hashOfMap(e){let t=Object.entries(e).filter(([,e])=>void 0!==e).map(([e,t])=>{let r=hashString(e),o=hashValue(t);return[r,o]}),r=t.sort(([e],[t])=>(0,i.qu)(e,t)),o=(0,a.eV)(...r.map(e=>(0,a.eV)(...e))),n=(0,d.JQ)(o);return n}},3416:(e,t,r)=>{function uint8FromBufLike(e){if(!e)throw Error("Input cannot be null or undefined");return e instanceof Uint8Array?e:e instanceof ArrayBuffer||Array.isArray(e)?new Uint8Array(e):"buffer"in e?uint8FromBufLike(e.buffer):new Uint8Array(e)}function uint8Equals(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}r.d(t,{ZP:()=>uint8FromBufLike,mK:()=>uint8Equals})},9492:(e,t,r)=>{function ilog2(e){let t=BigInt(e);if(e<=0)throw RangeError("Input must be positive");return t.toString(2).length-1}function iexp2(e){let t=BigInt(e);if(e<0)throw RangeError("Input must be non-negative");return BigInt(1)<<t}r.d(t,{m:()=>iexp2,p:()=>ilog2})},2484:(e,t,r)=>{function concat(...e){let t=new Uint8Array(e.reduce((e,t)=>e+t.byteLength,0)),r=0;for(let o of e)t.set(o,r),r+=o.byteLength;return t}r.d(t,{P8:()=>PipeArrayBuffer,ZP:()=>uint8FromBufLike,mK:()=>uint8Equals,qu:()=>compare,rQ:()=>uint8ToDataView,zo:()=>concat});let PipeArrayBuffer=class PipeArrayBuffer{save(){return this._view}restore(e){if(!(e instanceof Uint8Array))throw Error("Checkpoint must be a Uint8Array");this._view=e}constructor(e,t=e?.byteLength||0){if(e&&!(e instanceof Uint8Array))try{e=uint8FromBufLike(e)}catch{throw Error("Buffer must be a Uint8Array")}if(t<0||!Number.isInteger(t))throw Error("Length must be a non-negative integer");if(e&&t>e.byteLength)throw Error("Length cannot exceed buffer length");this._buffer=e||new Uint8Array(0),this._view=new Uint8Array(this._buffer.buffer,0,t)}get buffer(){return this._view.slice()}get byteLength(){return this._view.byteLength}read(e){let t=this._view.subarray(0,e);return this._view=this._view.subarray(e),t.slice()}readUint8(){if(0===this._view.byteLength)return;let e=this._view[0];return this._view=this._view.subarray(1),e}write(e){if(!(e instanceof Uint8Array))throw Error("Buffer must be a Uint8Array");let t=this._view.byteLength;this._view.byteOffset+this._view.byteLength+e.byteLength>=this._buffer.byteLength?this.alloc(e.byteLength):this._view=new Uint8Array(this._buffer.buffer,this._view.byteOffset,this._view.byteLength+e.byteLength),this._view.set(e,t)}get end(){return 0===this._view.byteLength}alloc(e){if(e<=0||!Number.isInteger(e))throw Error("Amount must be a positive integer");let t=new Uint8Array((this._buffer.byteLength+e)*1.2|0),r=new Uint8Array(t.buffer,0,this._view.byteLength+e);r.set(this._view),this._buffer=t,this._view=r}};function uint8FromBufLike(e){if(!e)throw Error("Input cannot be null or undefined");return e instanceof Uint8Array?e:e instanceof ArrayBuffer||Array.isArray(e)?new Uint8Array(e):"buffer"in e?uint8FromBufLike(e.buffer):new Uint8Array(e)}function compare(e,t){if(e.byteLength!==t.byteLength)return e.byteLength-t.byteLength;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]-t[r];return 0}function uint8Equals(e,t){return 0===compare(e,t)}function uint8ToDataView(e){if(!(e instanceof Uint8Array))throw Error("Input must be a Uint8Array");return new DataView(e.buffer,e.byteOffset,e.byteLength)}},648:(e,t,r)=>{r.d(t,{DM:()=>safeRead,Lu:()=>readUIntLE,U1:()=>safeReadUint8,VB:()=>writeIntLE,WB:()=>slebDecode,aC:()=>lebDecode,dZ:()=>lebEncode,dz:()=>readIntLE,nB:()=>slebEncode,nE:()=>writeUIntLE});var o=r(2484),i=r(9492);function eob(){throw Error("unexpected end of buffer")}function safeRead(e,t){return e.byteLength<t&&eob(),e.read(t)}function safeReadUint8(e){let t=e.readUint8();return void 0===t&&eob(),t}function lebEncode(e){if("number"==typeof e&&(e=BigInt(e)),e<BigInt(0))throw Error("Cannot leb encode negative values.");let t=(e===BigInt(0)?0:(0,i.p)(e))+1,r=new o.P8(new Uint8Array(t),0);for(;;){let t=Number(e&BigInt(127));if((e/=BigInt(128))===BigInt(0)){r.write(new Uint8Array([t]));break}r.write(new Uint8Array([128|t]))}return r.buffer}function lebDecode(e){let t,r=BigInt(1),o=BigInt(0);do o+=BigInt(127&(t=safeReadUint8(e))).valueOf()*r,r*=BigInt(128);while(t>=128);return o}function slebEncode(e){"number"==typeof e&&(e=BigInt(e));let t=e<BigInt(0);t&&(e=-e-BigInt(1));let r=(e===BigInt(0)?0:(0,i.p)(e))+1,n=new o.P8(new Uint8Array(r),0);for(;;){let r=getLowerBytes(e);if(e/=BigInt(128),t&&e===BigInt(0)&&(64&r)!=0||!t&&e===BigInt(0)&&(64&r)==0){n.write(new Uint8Array([r]));break}n.write(new Uint8Array([128|r]))}function getLowerBytes(e){let r=e%BigInt(128);return t?Number(BigInt(128)-r-BigInt(1)):Number(r)}return n.buffer}function slebDecode(e){let t=new Uint8Array(e.buffer),r=0;for(;r<t.byteLength;r++)if(t[r]<128){if((64&t[r])==0)return lebDecode(e);break}let o=new Uint8Array(safeRead(e,r+1)),i=BigInt(0);for(let e=o.byteLength-1;e>=0;e--)i=i*BigInt(128)+BigInt(128-(127&o[e])-1);return-i-BigInt(1)}function writeUIntLE(e,t){if(BigInt(e)<BigInt(0))throw Error("Cannot write negative values.");return writeIntLE(e,t)}function writeIntLE(e,t){e=BigInt(e);let r=new o.P8(new Uint8Array(Math.min(1,t)),0),i=0,n=BigInt(256),s=BigInt(0),a=Number(e%n);for(r.write(new Uint8Array([a]));++i<t;)e<0&&s===BigInt(0)&&0!==a&&(s=BigInt(1)),a=Number((e/n-s)%BigInt(256)),r.write(new Uint8Array([a])),n*=BigInt(256);return r.buffer}function readUIntLE(e,t){if(t<=0||!Number.isInteger(t))throw Error("Byte length must be a positive integer");let r=BigInt(safeReadUint8(e)),o=BigInt(1),i=0;for(;++i<t;){o*=BigInt(256);let t=BigInt(safeReadUint8(e));r+=o*t}return r}function readIntLE(e,t){if(t<=0||!Number.isInteger(t))throw Error("Byte length must be a positive integer");let r=readUIntLE(e,t),o=BigInt(2)**(BigInt(8)*BigInt(t-1)+BigInt(7));return r>=o&&(r-=o*BigInt(2)),r}},7668:(e,t,r)=>{r.d(t,{R:()=>Principal});let o="abcdefghijklmnopqrstuvwxyz234567",i=Object.create(null);for(let e=0;e<o.length;e++)i[o[e]]=e;function base32Encode(e){let t=0,r=0,i="";function encodeByte(e){return(t<0?r|=e>>-t:r=e<<t&248,t>3)?(t-=8,1):(t<4&&(i+=o[r>>3],t+=5),0)}for(let t=0;t<e.length;)t+=encodeByte(e[t]);return i+(t<0?o[r>>3]:"")}function base32Decode(e){let t=0,r=0,o=new Uint8Array(4*e.length/3|0),n=0;function decodeChar(e){let s=i[e.toLowerCase()];if(void 0===s)throw Error(`Invalid character: ${JSON.stringify(e)}`);s<<=3,r|=s>>>t,(t+=5)>=8&&(o[n++]=r,t-=8,r=t>0?s<<5-t&255:0)}for(let t of e)decodeChar(t);return o.slice(0,n)}i["0"]=i.o,i["1"]=i.i;let n=new Uint32Array([0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117]);function getCrc32(e){let t=-1;for(let r=0;r<e.length;r++){let o=e[r],i=(o^t)&255;t=n[i]^t>>>8}return(-1^t)>>>0}var s=r(7742),a=r(1947);let d="__principal__";let Principal=class Principal{static anonymous(){return new this(new Uint8Array([4]))}static managementCanister(){return this.fromText("aaaaa-aa")}static selfAuthenticating(e){let t=(0,s.gX)(e);return new this(new Uint8Array([...t,2]))}static from(e){if("string"==typeof e)return Principal.fromText(e);if(Object.getPrototypeOf(e)===Uint8Array.prototype)return new Principal(e);if(Principal.isPrincipal(e))return new Principal(e._arr);throw Error(`Impossible to convert ${JSON.stringify(e)} to Principal.`)}static fromHex(e){return new this((0,a.nr)(e))}static fromText(e){let t=e;if(e.includes(d)){let r=JSON.parse(e);d in r&&(t=r[d])}let r=t.toLowerCase().replace(/-/g,""),o=base32Decode(r);o=o.slice(4,o.length);let i=new this(o);if(i.toText()!==t)throw Error(`Principal "${i.toText()}" does not have a valid checksum (original value "${t}" may not be a valid Principal ID).`);return i}static fromUint8Array(e){return new this(e)}static isPrincipal(e){return e instanceof Principal||"object"==typeof e&&null!==e&&"_isPrincipal"in e&&!0===e._isPrincipal&&"_arr"in e&&e._arr instanceof Uint8Array}constructor(e){this._arr=e,this._isPrincipal=!0}isAnonymous(){return 1===this._arr.byteLength&&4===this._arr[0]}toUint8Array(){return this._arr}toHex(){return(0,a.ci)(this._arr).toUpperCase()}toText(){let e=new ArrayBuffer(4),t=new DataView(e);t.setUint32(0,getCrc32(this._arr));let r=new Uint8Array(e),o=new Uint8Array([...r,...this._arr]),i=base32Encode(o),n=i.match(/.{1,5}/g);if(!n)throw Error();return n.join("-")}toString(){return this.toText()}toJSON(){return{[d]:this.toText()}}compareTo(e){for(let t=0;t<Math.min(this._arr.length,e._arr.length);t++){if(this._arr[t]<e._arr[t])return"lt";if(this._arr[t]>e._arr[t])return"gt"}return this._arr.length<e._arr.length?"lt":this._arr.length>e._arr.length?"gt":"eq"}ltEq(e){let t=this.compareTo(e);return"lt"==t||"eq"==t}gtEq(e){let t=this.compareTo(e);return"gt"==t||"eq"==t}}},2435:(e,t,r)=>{r.d(t,{A1:()=>normalizeZ,D1:()=>pippenger,Mx:()=>wNAF,N6:()=>mulEndoUnsafe,rO:()=>_createCurveFields,xg:()=>negateCt});var o=r(1270),i=r(3751);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=BigInt(0),s=BigInt(1);function negateCt(e,t){let r=t.negate();return e?r:t}function normalizeZ(e,t){let r=(0,i.Eg)(e.Fp,t.map(e=>e.Z));return t.map((t,o)=>e.fromAffine(t.toAffine(r[o])))}function validateW(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw Error("invalid window size, expected [1.."+t+"], got W="+e)}function calcWOpts(e,t){validateW(e,t);let r=Math.ceil(t/e)+1,i=2**(e-1),n=2**e,s=(0,o.dQ)(e),a=BigInt(e);return{windows:r,windowSize:i,mask:s,maxNumber:n,shiftBy:a}}function calcOffsets(e,t,r){let{windowSize:o,mask:i,maxNumber:n,shiftBy:a}=r,d=Number(e&i),u=e>>a;d>o&&(d-=n,u+=s);let c=t*o,f=c+Math.abs(d)-1,h=0===d,l=d<0;return{nextN:u,offset:f,isZero:h,isNeg:l,isNegF:t%2!=0,offsetF:c}}function validateMSMPoints(e,t){if(!Array.isArray(e))throw Error("array expected");e.forEach((e,r)=>{if(!(e instanceof t))throw Error("invalid point at index "+r)})}function validateMSMScalars(e,t){if(!Array.isArray(e))throw Error("array of scalars expected");e.forEach((e,r)=>{if(!t.isValid(e))throw Error("invalid scalar at index "+r)})}let a=new WeakMap,d=new WeakMap;function getW(e){return d.get(e)||1}function assert0(e){if(e!==n)throw Error("invalid wNAF")}let wNAF=class wNAF{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let o=e;for(;t>n;)t&s&&(r=r.add(o)),o=o.double(),t>>=s;return r}precomputeWindow(e,t){let{windows:r,windowSize:o}=calcWOpts(t,this.bits),i=[],n=e,s=n;for(let e=0;e<r;e++){s=n,i.push(s);for(let e=1;e<o;e++)s=s.add(n),i.push(s);n=s.double()}return i}wNAF(e,t,r){if(!this.Fn.isValid(r))throw Error("invalid scalar");let o=this.ZERO,i=this.BASE,n=calcWOpts(e,this.bits);for(let e=0;e<n.windows;e++){let{nextN:s,offset:a,isZero:d,isNeg:u,isNegF:c,offsetF:f}=calcOffsets(r,e,n);r=s,d?i=i.add(negateCt(c,t[f])):o=o.add(negateCt(u,t[a]))}return assert0(r),{p:o,f:i}}wNAFUnsafe(e,t,r,o=this.ZERO){let i=calcWOpts(e,this.bits);for(let e=0;e<i.windows&&r!==n;e++){let{nextN:n,offset:s,isZero:a,isNeg:d}=calcOffsets(r,e,i);if(r=n,!a){let e=t[s];o=o.add(d?e.negate():e)}}return assert0(r),o}getPrecomputes(e,t,r){let o=a.get(t);return o||(o=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(o=r(o)),a.set(t,o))),o}cached(e,t,r){let o=getW(e);return this.wNAF(o,this.getPrecomputes(o,e,r),t)}unsafe(e,t,r,o){let i=getW(e);return 1===i?this._unsafeLadder(e,t,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,r),t,o)}createCache(e,t){validateW(t,this.bits),d.set(e,t),a.delete(e)}hasCache(e){return 1!==getW(e)}};function mulEndoUnsafe(e,t,r,o){let i=t,a=e.ZERO,d=e.ZERO;for(;r>n||o>n;)r&s&&(a=a.add(i)),o&s&&(d=d.add(i)),i=i.double(),r>>=s,o>>=s;return{p1:a,p2:d}}function pippenger(e,t,r,i){validateMSMPoints(r,e),validateMSMScalars(i,t);let n=r.length,s=i.length;if(n!==s)throw Error("arrays of points and scalars must have equal length");let a=e.ZERO,d=(0,o.Dd)(BigInt(n)),u=1;d>12?u=d-3:d>4?u=d-2:d>0&&(u=2);let c=(0,o.dQ)(u),f=Array(Number(c)+1).fill(a),h=Math.floor((t.BITS-1)/u)*u,l=a;for(let e=h;e>=0;e-=u){f.fill(a);for(let t=0;t<s;t++){let o=i[t],n=Number(o>>BigInt(e)&c);f[n]=f[n].add(r[t])}let t=a;for(let e=f.length-1,r=a;e>0;e--)r=r.add(f[e]),t=t.add(r);if(l=l.add(t),0!==e)for(let e=0;e<u;e++)l=l.double()}return l}function createField(e,t,r){if(!t)return(0,i.gN)(e,{isLE:r});if(t.ORDER!==e)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,i.OP)(t),t}function _createCurveFields(e,t,r={},o){if(void 0===o&&(o="edwards"===e),!t||"object"!=typeof t)throw Error(`expected valid ${e} CURVE object`);for(let e of["p","n","h"]){let r=t[e];if(!("bigint"==typeof r&&r>n))throw Error(`CURVE.${e} must be positive bigint`)}let i=createField(t.p,r.Fp,o),s=createField(t.n,r.Fn,o);for(let r of["Gx","Gy","a","weierstrass"===e?"b":"d"])if(!i.isValid(t[r]))throw Error(`CURVE.${r} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:i,Fn:s}}},2612:(e,t,r)=>{r.d(t,{Fc:()=>a,V1:()=>createHasher,eO:()=>expand_message_xmd,i:()=>isogenyMap});var o=r(1270),i=r(1947),n=r(3751);let s=o.Hv;function i2osp(e,t){if(anum(e),anum(t),e<0||e>=1<<8*t)throw Error("invalid I2OSP input: "+e);let r=Array.from({length:t}).fill(0);for(let o=t-1;o>=0;o--)r[o]=255&e,e>>>=8;return new Uint8Array(r)}function strxor(e,t){let r=new Uint8Array(e.length);for(let o=0;o<e.length;o++)r[o]=e[o]^t[o];return r}function anum(e){if(!Number.isSafeInteger(e))throw Error("number expected")}function normDST(e){if(!(0,i._t)(e)&&"string"!=typeof e)throw Error("DST must be Uint8Array or string");return"string"==typeof e?(0,i.iY)(e):e}function expand_message_xmd(e,t,r,o){(0,i.gk)(e),anum(r),(t=normDST(t)).length>255&&(t=o((0,i.eV)((0,i.iY)("H2C-OVERSIZE-DST-"),t)));let{outputLen:n,blockLen:s}=o,a=Math.ceil(r/n);if(r>65535||a>255)throw Error("expand_message_xmd: invalid lenInBytes");let d=(0,i.eV)(t,i2osp(t.length,1)),u=i2osp(0,s),c=i2osp(r,2),f=Array(a),h=o((0,i.eV)(u,e,c,i2osp(0,1),d));f[0]=o((0,i.eV)(h,i2osp(1,1),d));for(let e=1;e<=a;e++){let t=[strxor(h,f[e-1]),i2osp(e+1,1),d];f[e]=o((0,i.eV)(...t))}let l=(0,i.eV)(...f);return l.slice(0,r)}function expand_message_xof(e,t,r,o,n){if((0,i.gk)(e),anum(r),(t=normDST(t)).length>255&&(t=n.create({dkLen:Math.ceil(2*o/8)}).update((0,i.iY)("H2C-OVERSIZE-DST-")).update(t).digest()),r>65535||t.length>255)throw Error("expand_message_xof: invalid lenInBytes");return n.create({dkLen:r}).update(e).update(i2osp(r,2)).update(t).update(i2osp(t.length,1)).digest()}function hash_to_field(e,t,r){let a;(0,o.fA)(r,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:d,k:u,m:c,hash:f,expand:h,DST:l}=r;if(!(0,o.lt)(r.hash))throw Error("expected valid hash");(0,i.gk)(e),anum(t);let p=d.toString(2).length,g=Math.ceil((p+u)/8),y=t*c*g;if("xmd"===h)a=expand_message_xmd(e,l,y,f);else if("xof"===h)a=expand_message_xof(e,l,y,u,f);else if("_internal_pass"===h)a=e;else throw Error('expand must be "xmd" or "xof"');let m=Array(t);for(let e=0;e<t;e++){let t=Array(c);for(let r=0;r<c;r++){let o=g*(r+e*c),i=a.subarray(o,o+g);t[r]=(0,n.wQ)(s(i),d)}m[e]=t}return m}function isogenyMap(e,t){let r=t.map(e=>Array.from(e).reverse());return(t,o)=>{let[i,s,a,d]=r.map(r=>r.reduce((r,o)=>e.add(e.mul(r,t),o))),[u,c]=(0,n.Eg)(e,[s,d],!0);return t=e.mul(i,u),o=e.mul(o,e.mul(a,c)),{x:t,y:o}}}let a=(0,i.iY)("HashToScalar-");function createHasher(e,t,r){if("function"!=typeof t)throw Error("mapToCurve() must be defined");function map(r){return e.fromAffine(t(r))}function clear(t){let r=t.clearCofactor();return r.equals(e.ZERO)?e.ZERO:(r.assertValidity(),r)}return{defaults:r,hashToCurve(e,t){let o=Object.assign({},r,t),i=hash_to_field(e,2,o),n=map(i[0]),s=map(i[1]);return clear(n.add(s))},encodeToCurve(e,t){let o=r.encodeDST?{DST:r.encodeDST}:{},i=Object.assign({},r,o,t),n=hash_to_field(e,1,i),s=map(n[0]);return clear(s)},mapToCurve(e){if(!Array.isArray(e))throw Error("expected array of bigints");for(let t of e)if("bigint"!=typeof t)throw Error("expected array of bigints");return clear(map(e))},hashToScalar(t,o){let i=e.Fn.ORDER,n=Object.assign({},r,{p:i,m:1,DST:a},o);return hash_to_field(t,1,n)[0][0]}}}},3751:(e,t,r)=>{r.d(t,{Eg:()=>FpInvertBatch,IN:()=>FpLegendre,OP:()=>validateField,PS:()=>getMinHashLength,Q:()=>FpPow,Tu:()=>isNegativeLE,Us:()=>mapHashToField,gN:()=>Field,oA:()=>pow2,wQ:()=>mod});var o=r(1270),i=r(1947);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=BigInt(0),s=BigInt(1),a=BigInt(2),d=BigInt(3),u=BigInt(4),c=BigInt(5),f=BigInt(7),h=BigInt(8),l=BigInt(9),p=BigInt(16);function mod(e,t){let r=e%t;return r>=n?r:t+r}function pow2(e,t,r){let o=e;for(;t-- >n;)o*=o,o%=r;return o}function invert(e,t){if(e===n)throw Error("invert: expected non-zero number");if(t<=n)throw Error("invert: expected positive modulus, got "+t);let r=mod(e,t),o=t,i=n,a=s,d=s,u=n;for(;r!==n;){let e=o/r,t=o%r,n=i-d*e,s=a-u*e;o=r,r=t,i=d,a=u,d=n,u=s}let c=o;if(c!==s)throw Error("invert: does not exist");return mod(i,t)}function assertIsSquare(e,t,r){if(!e.eql(e.sqr(t),r))throw Error("Cannot find square root")}function sqrt3mod4(e,t){let r=(e.ORDER+s)/u,o=e.pow(t,r);return assertIsSquare(e,o,t),o}function sqrt5mod8(e,t){let r=(e.ORDER-c)/h,o=e.mul(t,a),i=e.pow(o,r),n=e.mul(t,i),s=e.mul(e.mul(n,a),i),d=e.mul(n,e.sub(s,e.ONE));return assertIsSquare(e,d,t),d}function sqrt9mod16(e){let t=Field(e),r=tonelliShanks(e),o=r(t,t.neg(t.ONE)),i=r(t,o),n=r(t,t.neg(o)),s=(e+f)/p;return(e,t)=>{let r=e.pow(t,s),a=e.mul(r,o),d=e.mul(r,i),u=e.mul(r,n),c=e.eql(e.sqr(a),t),f=e.eql(e.sqr(d),t);r=e.cmov(r,a,c),a=e.cmov(u,d,f);let h=e.eql(e.sqr(a),t),l=e.cmov(r,a,h);return assertIsSquare(e,l,t),l}}function tonelliShanks(e){if(e<d)throw Error("sqrt is not defined for small field");let t=e-s,r=0;for(;t%a===n;)t/=a,r++;let o=a,i=Field(e);for(;1===FpLegendre(i,o);)if(o++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===r)return sqrt3mod4;let u=i.pow(o,t),c=(t+s)/a;return function(e,o){if(e.is0(o))return o;if(1!==FpLegendre(e,o))throw Error("Cannot find square root");let i=r,n=e.mul(e.ONE,u),a=e.pow(o,t),d=e.pow(o,c);for(;!e.eql(a,e.ONE);){if(e.is0(a))return e.ZERO;let t=1,r=e.sqr(a);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===i)throw Error("Cannot find square root");let o=s<<BigInt(i-t-1),u=e.pow(n,o);i=t,n=e.sqr(u),a=e.mul(a,n),d=e.mul(d,u)}return d}}function FpSqrt(e){return e%u===d?sqrt3mod4:e%h===c?sqrt5mod8:e%p===l?sqrt9mod16(e):tonelliShanks(e)}let isNegativeLE=(e,t)=>(mod(e,t)&s)===s,g=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(e){let t=g.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,o.fA)(e,t),e}function FpPow(e,t,r){if(r<n)throw Error("invalid exponent, negatives unsupported");if(r===n)return e.ONE;if(r===s)return t;let o=e.ONE,i=t;for(;r>n;)r&s&&(o=e.mul(o,i)),i=e.sqr(i),r>>=s;return o}function FpInvertBatch(e,t,r=!1){let o=Array(t.length).fill(r?e.ZERO:void 0),i=t.reduce((t,r,i)=>e.is0(r)?t:(o[i]=t,e.mul(t,r)),e.ONE),n=e.inv(i);return t.reduceRight((t,r,i)=>e.is0(r)?t:(o[i]=e.mul(t,o[i]),e.mul(t,r)),n),o}function FpLegendre(e,t){let r=(e.ORDER-s)/a,o=e.pow(t,r),i=e.eql(o,e.ONE),n=e.eql(o,e.ZERO),d=e.eql(o,e.neg(e.ONE));if(!i&&!n&&!d)throw Error("invalid Legendre symbol result");return i?1:n?0:-1}function nLength(e,t){void 0!==t&&(0,i.k8)(t);let r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Field(e,t,r=!1,i={}){let a,d,u,c;if(e<=n)throw Error("invalid field: expected ORDER > 0, got "+e);let f=!1;if("object"==typeof t&&null!=t){if(i.sqrt||r)throw Error("cannot specify opts in two arguments");t.BITS&&(d=t.BITS),t.sqrt&&(u=t.sqrt),"boolean"==typeof t.isLE&&(r=t.isLE),"boolean"==typeof t.modFromBytes&&(f=t.modFromBytes),c=t.allowedLengths}else"number"==typeof t&&(d=t),i.sqrt&&(u=i.sqrt);let{nBitLength:h,nByteLength:l}=nLength(e,d);if(l>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let p=Object.freeze({ORDER:e,isLE:r,BITS:h,BYTES:l,MASK:(0,o.dQ)(h),ZERO:n,ONE:s,allowedLengths:c,create:t=>mod(t,e),isValid:t=>{if("bigint"!=typeof t)throw Error("invalid field element: expected bigint, got "+typeof t);return n<=t&&t<e},is0:e=>e===n,isValidNot0:e=>!p.is0(e)&&p.isValid(e),isOdd:e=>(e&s)===s,neg:t=>mod(-t,e),eql:(e,t)=>e===t,sqr:t=>mod(t*t,e),add:(t,r)=>mod(t+r,e),sub:(t,r)=>mod(t-r,e),mul:(t,r)=>mod(t*r,e),pow:(e,t)=>FpPow(p,e,t),div:(t,r)=>mod(t*invert(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>invert(t,e),sqrt:u||(t=>(a||(a=FpSqrt(e)),a(p,t))),toBytes:e=>r?(0,o.S5)(e,l):(0,o.tL)(e,l),fromBytes:(t,i=!0)=>{if(c){if(!c.includes(t.length)||t.length>l)throw Error("Field.fromBytes: expected "+c+" bytes, got "+t.length);let e=new Uint8Array(l);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==l)throw Error("Field.fromBytes: expected "+l+" bytes, got "+t.length);let n=r?(0,o.ty)(t):(0,o.Hv)(t);if(f&&(n=mod(n,e)),!i&&!p.isValid(n))throw Error("invalid field element: outside of range 0..ORDER");return n},invertBatch:e=>FpInvertBatch(p,e),cmov:(e,t,r)=>r?t:e});return Object.freeze(p)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw Error("field order must be bigint");let t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){let t=getFieldBytesLength(e);return t+Math.ceil(t/2)}function mapHashToField(e,t,r=!1){let i=e.length,n=getFieldBytesLength(t),a=getMinHashLength(t);if(i<16||i<a||i>1024)throw Error("expected "+a+"-1024 bytes of input, got "+i);let d=r?(0,o.ty)(e):(0,o.Hv)(e),u=mod(d,t-s)+s;return r?(0,o.S5)(u,n):(0,o.tL)(u,n)}},1125:(e,t,r)=>{r.d(t,{UN:()=>B});var o=r(7742),i=r(1947),n=r(2435),s=r(1270),a=r(3751);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let d=BigInt(0),u=BigInt(1),c=BigInt(2),f=BigInt(8);function isEdValidXY(e,t,r,o){let i=e.sqr(r),n=e.sqr(o),s=e.add(e.mul(t.a,i),n),a=e.add(e.ONE,e.mul(t.d,e.mul(i,n)));return e.eql(s,a)}function edwards(e,t={}){let r=(0,n.rO)("edwards",e,t,t.FpFnLE),{Fp:o,Fn:a}=r,h=r.CURVE,{h:l}=h;(0,s.fA)(t,{},{uvRatio:"function"});let p=c<<BigInt(8*a.BYTES)-u,modP=e=>o.create(e),g=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:o.sqrt(o.div(e,t))}}catch(e){return{isValid:!1,value:d}}});if(!isEdValidXY(o,h,h.Gx,h.Gy))throw Error("bad curve params: generator point");function acoord(e,t,r=!1){let o=r?u:d;return(0,s.Fy)("coordinate "+e,t,o,p),t}function aextpoint(e){if(!(e instanceof Point))throw Error("ExtendedPoint expected")}let y=(0,s.H9)((e,t)=>{let{X:r,Y:i,Z:n}=e,s=e.is0();null==t&&(t=s?f:o.inv(n));let a=modP(r*t),c=modP(i*t),h=o.mul(n,t);if(s)return{x:d,y:u};if(h!==u)throw Error("invZ was invalid");return{x:a,y:c}}),m=(0,s.H9)(e=>{let{a:t,d:r}=h;if(e.is0())throw Error("bad point: ZERO");let{X:o,Y:i,Z:n,T:s}=e,a=modP(o*o),d=modP(i*i),u=modP(n*n),c=modP(u*u),f=modP(a*t),l=modP(u*modP(f+d)),p=modP(c+modP(r*modP(a*d)));if(l!==p)throw Error("bad point: equation left != right (1)");let g=modP(o*i),y=modP(n*s);if(g!==y)throw Error("bad point: equation left != right (2)");return!0});let Point=class Point{constructor(e,t,r,o){this.X=acoord("x",e),this.Y=acoord("y",t),this.Z=acoord("z",r,!0),this.T=acoord("t",o),Object.freeze(this)}static CURVE(){return h}static fromAffine(e){if(e instanceof Point)throw Error("extended point not allowed");let{x:t,y:r}=e||{};return acoord("x",t),acoord("y",r),new Point(t,r,u,modP(t*r))}static fromBytes(e,t=!1){let r=o.BYTES,{a:i,d:n}=h;e=(0,s.HV)((0,s.GB)(e,r,"point")),(0,s.po)(t,"zip215");let a=(0,s.HV)(e),c=e[r-1];a[r-1]=-129&c;let f=(0,s.ty)(a),l=t?p:o.ORDER;(0,s.Fy)("point.y",f,d,l);let y=modP(f*f),m=modP(y-u),E=modP(n*y-i),{isValid:b,value:x}=g(m,E);if(!b)throw Error("bad point: invalid y coordinate");let w=(x&u)===u,C=(128&c)!=0;if(!t&&x===d&&C)throw Error("bad point: x=0 and x_0=1");return C!==w&&(x=modP(-x)),Point.fromAffine({x,y:f})}static fromHex(e,t=!1){return Point.fromBytes((0,s.ql)("point",e),t)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return E.createCache(this,e),t||this.multiply(c),this}assertValidity(){m(this)}equals(e){aextpoint(e);let{X:t,Y:r,Z:o}=this,{X:i,Y:n,Z:s}=e,a=modP(t*s),d=modP(i*o),u=modP(r*s),c=modP(n*o);return a===d&&u===c}is0(){return this.equals(Point.ZERO)}negate(){return new Point(modP(-this.X),this.Y,this.Z,modP(-this.T))}double(){let{a:e}=h,{X:t,Y:r,Z:o}=this,i=modP(t*t),n=modP(r*r),s=modP(c*modP(o*o)),a=modP(e*i),d=t+r,u=modP(modP(d*d)-i-n),f=a+n,l=f-s,p=a-n,g=modP(u*l),y=modP(f*p),m=modP(u*p),E=modP(l*f);return new Point(g,y,E,m)}add(e){aextpoint(e);let{a:t,d:r}=h,{X:o,Y:i,Z:n,T:s}=this,{X:a,Y:d,Z:u,T:c}=e,f=modP(o*a),l=modP(i*d),p=modP(s*r*c),g=modP(n*u),y=modP((o+i)*(a+d)-f-l),m=g-p,E=g+p,b=modP(l-t*f),x=modP(y*m),w=modP(E*b),C=modP(y*b),B=modP(m*E);return new Point(x,w,B,C)}subtract(e){return this.add(e.negate())}multiply(e){if(!a.isValidNot0(e))throw Error("invalid scalar: expected 1 <= sc < curve.n");let{p:t,f:r}=E.cached(this,e,e=>(0,n.A1)(Point,e));return(0,n.A1)(Point,[t,r])[0]}multiplyUnsafe(e,t=Point.ZERO){if(!a.isValid(e))throw Error("invalid scalar: expected 0 <= sc < curve.n");return e===d?Point.ZERO:this.is0()||e===u?this:E.unsafe(this,e,e=>(0,n.A1)(Point,e),t)}isSmallOrder(){return this.multiplyUnsafe(l).is0()}isTorsionFree(){return E.unsafe(this,h.n).is0()}toAffine(e){return y(this,e)}clearCofactor(){return l===u?this:this.multiplyUnsafe(l)}toBytes(){let{x:e,y:t}=this.toAffine(),r=o.toBytes(t);return r[r.length-1]|=e&u?128:0,r}toHex(){return(0,i.ci)(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(e){return(0,n.A1)(Point,e)}static msm(e,t){return(0,n.D1)(Point,a,e,t)}_setWindowSize(e){this.precompute(e)}toRawBytes(){return this.toBytes()}};Point.BASE=new Point(h.Gx,h.Gy,u,modP(h.Gx*h.Gy)),Point.ZERO=new Point(d,u,u,d),Point.Fp=o,Point.Fn=a;let E=new n.Mx(Point,a.BITS);return Point.BASE.precompute(8),Point}let PrimeEdwardsPoint=class PrimeEdwardsPoint{constructor(e){this.ep=e}static fromBytes(e){(0,s.EQ)()}static fromHex(e){(0,s.EQ)()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(e){return this.ep.toAffine(e)}toHex(){return(0,i.ci)(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(e){return this.assertSame(e),this.init(this.ep.add(e.ep))}subtract(e){return this.assertSame(e),this.init(this.ep.subtract(e.ep))}multiply(e){return this.init(this.ep.multiply(e))}multiplyUnsafe(e){return this.init(this.ep.multiplyUnsafe(e))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(e,t){return this.init(this.ep.precompute(e,t))}toRawBytes(){return this.toBytes()}};function eddsa(e,t,r={}){if("function"!=typeof t)throw Error('"hash" function param is required');(0,s.fA)(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});let{prehash:o}=r,{BASE:n,Fp:a,Fn:d}=e,c=r.randomBytes||i.O6,f=r.adjustScalarBytes||(e=>e),h=r.domain||((e,t,r)=>{if((0,s.po)(r,"phflag"),t.length||r)throw Error("Contexts/pre-hash are not supported");return e});function modN_LE(e){return d.create((0,s.ty)(e))}function getPrivateScalar(e){let r=g.secretKey;e=(0,s.ql)("private key",e,r);let o=(0,s.ql)("hashed private key",t(e),2*r),i=f(o.slice(0,r)),n=o.slice(r,2*r),a=modN_LE(i);return{head:i,prefix:n,scalar:a}}function getExtendedPublicKey(e){let{head:t,prefix:r,scalar:o}=getPrivateScalar(e),i=n.multiply(o),s=i.toBytes();return{head:t,prefix:r,scalar:o,point:i,pointBytes:s}}function getPublicKey(e){return getExtendedPublicKey(e).pointBytes}function hashDomainToScalar(e=Uint8Array.of(),...r){let n=(0,i.eV)(...r);return modN_LE(t(h(n,(0,s.ql)("context",e),!!o)))}function sign(e,t,r={}){e=(0,s.ql)("message",e),o&&(e=o(e));let{prefix:a,scalar:u,pointBytes:c}=getExtendedPublicKey(t),f=hashDomainToScalar(r.context,a,e),h=n.multiply(f).toBytes(),l=hashDomainToScalar(r.context,h,c,e),p=d.create(f+l*u);if(!d.isValid(p))throw Error("sign failed: invalid s");let y=(0,i.eV)(h,d.toBytes(p));return(0,s.GB)(y,g.signature,"result")}let l={zip215:!0};function verify(t,r,i,a=l){let d,u,c;let{context:f,zip215:h}=a,p=g.signature;t=(0,s.ql)("signature",t,p),r=(0,s.ql)("message",r),i=(0,s.ql)("publicKey",i,g.publicKey),void 0!==h&&(0,s.po)(h,"zip215"),o&&(r=o(r));let y=p/2,m=t.subarray(0,y),E=(0,s.ty)(t.subarray(y,p));try{d=e.fromBytes(i,h),u=e.fromBytes(m,h),c=n.multiplyUnsafe(E)}catch(e){return!1}if(!h&&d.isSmallOrder())return!1;let b=hashDomainToScalar(f,u.toBytes(),d.toBytes(),r),x=u.add(d.multiplyUnsafe(b));return x.subtract(c).clearCofactor().is0()}let p=a.BYTES,g={secretKey:p,publicKey:p,signature:2*p,seed:p};function randomSecretKey(e=c(g.seed)){return(0,s.GB)(e,g.seed,"seed")}function keygen(e){let t=y.randomSecretKey(e);return{secretKey:t,publicKey:getPublicKey(t)}}function isValidSecretKey(e){return(0,i._t)(e)&&e.length===d.BYTES}function isValidPublicKey(t,r){try{return!!e.fromBytes(t,r)}catch(e){return!1}}let y={getExtendedPublicKey,randomSecretKey,isValidSecretKey,isValidPublicKey,toMontgomery(t){let{y:r}=e.fromBytes(t),o=g.publicKey,i=32===o;if(!i&&57!==o)throw Error("only defined for 25519 and 448");let n=i?a.div(u+r,u-r):a.div(r-u,r+u);return a.toBytes(n)},toMontgomerySecret(e){let r=g.secretKey;(0,s.GB)(e,r);let o=t(e.subarray(0,r));return f(o).subarray(0,r)},randomPrivateKey:randomSecretKey,precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({keygen,getPublicKey,sign,verify,utils:y,Point:e,lengths:g})}function _eddsa_legacy_opts_to_new(e){let t={a:e.a,d:e.d,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp,o=(0,a.gN)(t.n,e.nBitLength,!0),i={Fp:r,Fn:o,uvRatio:e.uvRatio},n={randomBytes:e.randomBytes,adjustScalarBytes:e.adjustScalarBytes,domain:e.domain,prehash:e.prehash,mapToCurve:e.mapToCurve};return{CURVE:t,curveOpts:i,hash:e.hash,eddsaOpts:n}}function _eddsa_new_output_to_legacy(e,t){let r=t.Point,o=Object.assign({},t,{ExtendedPoint:r,CURVE:e,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES});return o}function edwards_twistedEdwards(e){let{CURVE:t,curveOpts:r,hash:o,eddsaOpts:i}=_eddsa_legacy_opts_to_new(e),n=edwards(t,r),s=eddsa(n,o,i);return _eddsa_new_output_to_legacy(e,s)}r(2612);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let h=BigInt(0),l=BigInt(1),p=BigInt(2);BigInt(3);let g=BigInt(5),y=BigInt(8),m=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),E={p:m,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:y,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function ed25519_pow_2_252_3(e){let t=BigInt(10),r=BigInt(20),o=BigInt(40),i=BigInt(80),n=e*e%m,s=n*e%m,d=(0,a.oA)(s,p,m)*s%m,u=(0,a.oA)(d,l,m)*e%m,c=(0,a.oA)(u,g,m)*u%m,f=(0,a.oA)(c,t,m)*c%m,h=(0,a.oA)(f,r,m)*f%m,y=(0,a.oA)(h,o,m)*h%m,E=(0,a.oA)(y,i,m)*y%m,b=(0,a.oA)(E,i,m)*y%m,x=(0,a.oA)(b,t,m)*c%m,w=(0,a.oA)(x,p,m)*e%m;return{pow_p_5_8:w,b2:s}}function adjustScalarBytes(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}let b=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function uvRatio(e,t){let r=(0,a.wQ)(t*t*t,m),o=(0,a.wQ)(r*r*t,m),i=ed25519_pow_2_252_3(e*o).pow_p_5_8,n=(0,a.wQ)(e*r*i,m),s=(0,a.wQ)(t*n*n,m),d=n,u=(0,a.wQ)(n*b,m),c=s===e,f=s===(0,a.wQ)(-e,m),h=s===(0,a.wQ)(-e*b,m);return c&&(n=d),(f||h)&&(n=u),(0,a.Tu)(n,m)&&(n=(0,a.wQ)(-n,m)),{isValid:c||f,value:n}}let x=(0,a.gN)(E.p,{isLE:!0}),w=(0,a.gN)(E.n,{isLE:!0}),C={...E,Fp:x,hash:o.o,adjustScalarBytes,uvRatio},B=edwards_twistedEdwards(C),I=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),P=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),v=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),A=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),invertSqrt=e=>uvRatio(l,e),O=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),bytes255ToNumberLE=e=>B.Point.Fp.create((0,s.ty)(e)&O);function calcElligatorRistrettoMap(e){let{d:t}=E,mod=e=>x.create(e),r=mod(b*e*e),o=mod((r+l)*v),i=BigInt(-1),n=mod((i-t*r)*mod(r+t)),{isValid:s,value:d}=uvRatio(o,n),u=mod(d*e);(0,a.Tu)(u,m)||(u=mod(-u)),s||(d=u),s||(i=r);let c=mod(i*(r-l)*A-n),f=d*d,h=mod((d+d)*n),p=mod(c*I),g=mod(l-f),y=mod(l+f);return new B.Point(mod(h*y),mod(g*p),mod(p*y),mod(h*g))}function ristretto255_map(e){(0,i.gk)(e,64);let t=bytes255ToNumberLE(e.subarray(0,32)),r=calcElligatorRistrettoMap(t),o=bytes255ToNumberLE(e.subarray(32,64)),n=calcElligatorRistrettoMap(o);return new _RistrettoPoint(r.add(n))}let _RistrettoPoint=class _RistrettoPoint extends PrimeEdwardsPoint{constructor(e){super(e)}static fromAffine(e){return new _RistrettoPoint(B.Point.fromAffine(e))}assertSame(e){if(!(e instanceof _RistrettoPoint))throw Error("RistrettoPoint expected")}init(e){return new _RistrettoPoint(e)}static hashToCurve(e){return ristretto255_map((0,s.ql)("ristrettoHash",e,64))}static fromBytes(e){(0,i.gk)(e,32);let{a:t,d:r}=E,mod=e=>x.create(e),o=bytes255ToNumberLE(e);if(!(0,s.Wd)(x.toBytes(o),e)||(0,a.Tu)(o,m))throw Error("invalid ristretto255 encoding 1");let n=mod(o*o),d=mod(l+t*n),u=mod(l-t*n),c=mod(d*d),f=mod(u*u),p=mod(t*r*c-f),{isValid:g,value:y}=invertSqrt(mod(p*f)),b=mod(y*u),w=mod(y*b*p),C=mod((o+o)*b);(0,a.Tu)(C,m)&&(C=mod(-C));let I=mod(d*w),P=mod(C*I);if(!g||(0,a.Tu)(P,m)||I===h)throw Error("invalid ristretto255 encoding 2");return new _RistrettoPoint(new B.Point(C,I,l,P))}static fromHex(e){return _RistrettoPoint.fromBytes((0,s.ql)("ristrettoHex",e,32))}static msm(e,t){return(0,n.D1)(_RistrettoPoint,B.Point.Fn,e,t)}toBytes(){let e,{X:t,Y:r,Z:o,T:i}=this.ep,mod=e=>x.create(e),n=mod(mod(o+r)*mod(o-r)),s=mod(t*r),d=mod(s*s),{value:u}=invertSqrt(mod(n*d)),c=mod(u*n),f=mod(u*s),h=mod(c*f*i);if((0,a.Tu)(i*h,m)){let o=mod(r*b),i=mod(t*b);t=o,r=i,e=mod(c*P)}else e=f;(0,a.Tu)(t*h,m)&&(r=mod(-r));let l=mod((o-r)*e);return(0,a.Tu)(l,m)&&(l=mod(-l)),x.toBytes(l)}equals(e){this.assertSame(e);let{X:t,Y:r}=this.ep,{X:o,Y:i}=e.ep,mod=e=>x.create(e),n=mod(t*i)===mod(r*o),s=mod(r*i)===mod(t*o);return n||s}is0(){return this.equals(_RistrettoPoint.ZERO)}};_RistrettoPoint.BASE=new _RistrettoPoint(B.Point.BASE),_RistrettoPoint.ZERO=new _RistrettoPoint(B.Point.ZERO),_RistrettoPoint.Fp=x,_RistrettoPoint.Fn=w},1270:(e,t,r)=>{r.d(t,{Dd:()=>bitLen,EQ:()=>notImplemented,Fy:()=>aInRange,GB:()=>_abytes2,H9:()=>memoized,HV:()=>copyBytes,H_:()=>bitGet,Hv:()=>bytesToNumberBE,S5:()=>numberToBytesLE,Wd:()=>equalBytes,Z2:()=>inRange,dQ:()=>bitMask,fA:()=>_validateObject,lt:()=>isHash,po:()=>_abool2,ql:()=>ensureBytes,tL:()=>numberToBytesBE,ty:()=>bytesToNumberLE,uz:()=>numberToHexUnpadded});var o=r(1947);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let i=BigInt(0),n=BigInt(1);function _abool2(e,t=""){if("boolean"!=typeof e){let r=t&&`"${t}"`;throw Error(r+"expected boolean, got type="+typeof e)}return e}function _abytes2(e,t,r=""){let i=(0,o._t)(e),n=e?.length,s=void 0!==t;if(!i||s&&n!==t){let o=r&&`"${r}" `,a=s?` of length ${t}`:"",d=i?`length=${n}`:`type=${typeof e}`;throw Error(o+"expected Uint8Array"+a+", got "+d)}return e}function numberToHexUnpadded(e){let t=e.toString(16);return 1&t.length?"0"+t:t}function hexToNumber(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?i:BigInt("0x"+e)}function bytesToNumberBE(e){return hexToNumber((0,o.ci)(e))}function bytesToNumberLE(e){return(0,o.gk)(e),hexToNumber((0,o.ci)(Uint8Array.from(e).reverse()))}function numberToBytesBE(e,t){return(0,o.nr)(e.toString(16).padStart(2*t,"0"))}function numberToBytesLE(e,t){return numberToBytesBE(e,t).reverse()}function ensureBytes(e,t,r){let i;if("string"==typeof t)try{i=(0,o.nr)(t)}catch(t){throw Error(e+" must be hex string or Uint8Array, cause: "+t)}else if((0,o._t)(t))i=Uint8Array.from(t);else throw Error(e+" must be hex string or Uint8Array");let n=i.length;if("number"==typeof r&&n!==r)throw Error(e+" of length "+r+" expected, got "+n);return i}function equalBytes(e,t){if(e.length!==t.length)return!1;let r=0;for(let o=0;o<e.length;o++)r|=e[o]^t[o];return 0===r}function copyBytes(e){return Uint8Array.from(e)}let isPosBig=e=>"bigint"==typeof e&&i<=e;function inRange(e,t,r){return isPosBig(e)&&isPosBig(t)&&isPosBig(r)&&t<=e&&e<r}function aInRange(e,t,r,o){if(!inRange(t,r,o))throw Error("expected valid "+e+": "+r+" <= n < "+o+", got "+t)}function bitLen(e){let t;for(t=0;e>i;e>>=n,t+=1);return t}function bitGet(e,t){return e>>BigInt(t)&n}let bitMask=e=>(n<<BigInt(e))-n;function isHash(e){return"function"==typeof e&&Number.isSafeInteger(e.outputLen)}function _validateObject(e,t,r={}){if(!e||"object"!=typeof e)throw Error("expected valid options object");function checkField(t,r,o){let i=e[t];if(o&&void 0===i)return;let n=typeof i;if(n!==r||null===i)throw Error(`param "${t}" is invalid: expected ${r}, got ${n}`)}Object.entries(t).forEach(([e,t])=>checkField(e,t,!1)),Object.entries(r).forEach(([e,t])=>checkField(e,t,!0))}let notImplemented=()=>{throw Error("not implemented")};function memoized(e){let t=new WeakMap;return(r,...o)=>{let i=t.get(r);if(void 0!==i)return i;let n=e(r,...o);return t.set(r,n),n}}},7742:(e,t,r)=>{r.d(t,{gX:()=>m,JQ:()=>y,o:()=>E});var o=r(1947);function setBigUint64(e,t,r,o){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,o);let i=BigInt(32),n=BigInt(4294967295),s=Number(r>>i&n),a=Number(r&n),d=o?4:0,u=o?0:4;e.setUint32(t+d,s,o),e.setUint32(t+u,a,o)}function Chi(e,t,r){return e&t^~e&r}function Maj(e,t,r){return e&t^e&r^t&r}let HashMD=class HashMD extends o.kb{constructor(e,t,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(e),this.view=(0,o.GL)(this.buffer)}update(e){(0,o.$h)(this),e=(0,o.O0)(e),(0,o.gk)(e);let{view:t,buffer:r,blockLen:i}=this,n=e.length;for(let s=0;s<n;){let a=Math.min(i-this.pos,n-s);if(a===i){let t=(0,o.GL)(e);for(;i<=n-s;s+=i)this.process(t,s);continue}r.set(e.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){(0,o.$h)(this),(0,o.eB)(e,this),this.finished=!0;let{buffer:t,view:r,blockLen:i,isLE:n}=this,{pos:s}=this;t[s++]=128,(0,o.ru)(this.buffer.subarray(s)),this.padOffset>i-s&&(this.process(r,0),s=0);for(let e=s;e<i;e++)t[e]=0;setBigUint64(r,i-8,BigInt(8*this.length),n),this.process(r,0);let a=(0,o.GL)(e),d=this.outputLen;if(d%4)throw Error("_sha2: outputLen should be aligned to 32bit");let u=d/4,c=this.get();if(u>c.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<u;e++)a.setUint32(4*e,c[e],n)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:r,length:o,finished:i,destroyed:n,pos:s}=this;return e.destroyed=n,e.finished=i,e.length=o,e.pos=s,o%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}};let i=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),n=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),s=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),a=BigInt(4294967296-1),d=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&a),l:Number(e>>d&a)}:{h:0|Number(e>>d&a),l:0|Number(e&a)}}function split(e,t=!1){let r=e.length,o=new Uint32Array(r),i=new Uint32Array(r);for(let n=0;n<r;n++){let{h:r,l:s}=fromBig(e[n],t);[o[n],i[n]]=[r,s]}return[o,i]}let shrSH=(e,t,r)=>e>>>r,shrSL=(e,t,r)=>e<<32-r|t>>>r,rotrSH=(e,t,r)=>e>>>r|t<<32-r,rotrSL=(e,t,r)=>e<<32-r|t>>>r,rotrBH=(e,t,r)=>e<<64-r|t>>>r-32,rotrBL=(e,t,r)=>e>>>r-32|t<<64-r;function add(e,t,r,o){let i=(t>>>0)+(o>>>0);return{h:e+r+(i/4294967296|0)|0,l:0|i}}let add3L=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H=(e,t,r,o)=>t+r+o+(e/4294967296|0)|0,add4L=(e,t,r,o)=>(e>>>0)+(t>>>0)+(r>>>0)+(o>>>0),add4H=(e,t,r,o,i)=>t+r+o+i+(e/4294967296|0)|0,add5L=(e,t,r,o,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(o>>>0)+(i>>>0),add5H=(e,t,r,o,i,n)=>t+r+o+i+n+(e/4294967296|0)|0,u=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),c=new Uint32Array(64);let SHA256=class SHA256 extends HashMD{constructor(e=32){super(64,e,8,!1),this.A=0|i[0],this.B=0|i[1],this.C=0|i[2],this.D=0|i[3],this.E=0|i[4],this.F=0|i[5],this.G=0|i[6],this.H=0|i[7]}get(){let{A:e,B:t,C:r,D:o,E:i,F:n,G:s,H:a}=this;return[e,t,r,o,i,n,s,a]}set(e,t,r,o,i,n,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|o,this.E=0|i,this.F=0|n,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)c[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){let t=c[e-15],r=c[e-2],i=(0,o.np)(t,7)^(0,o.np)(t,18)^t>>>3,n=(0,o.np)(r,17)^(0,o.np)(r,19)^r>>>10;c[e]=n+c[e-7]+i+c[e-16]|0}let{A:r,B:i,C:n,D:s,E:a,F:d,G:f,H:h}=this;for(let e=0;e<64;e++){let t=(0,o.np)(a,6)^(0,o.np)(a,11)^(0,o.np)(a,25),l=h+t+Chi(a,d,f)+u[e]+c[e]|0,p=(0,o.np)(r,2)^(0,o.np)(r,13)^(0,o.np)(r,22),g=p+Maj(r,i,n)|0;h=f,f=d,d=a,a=s+l|0,s=n,n=i,i=r,r=l+g|0}r=r+this.A|0,i=i+this.B|0,n=n+this.C|0,s=s+this.D|0,a=a+this.E|0,d=d+this.F|0,f=f+this.G|0,h=h+this.H|0,this.set(r,i,n,s,a,d,f,h)}roundClean(){(0,o.ru)(c)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,o.ru)(this.buffer)}};let SHA224=class SHA224 extends SHA256{constructor(){super(28),this.A=0|n[0],this.B=0|n[1],this.C=0|n[2],this.D=0|n[3],this.E=0|n[4],this.F=0|n[5],this.G=0|n[6],this.H=0|n[7]}};let f=split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),h=f[0],l=f[1],p=new Uint32Array(80),g=new Uint32Array(80);let SHA512=class SHA512 extends HashMD{constructor(e=64){super(128,e,16,!1),this.Ah=0|s[0],this.Al=0|s[1],this.Bh=0|s[2],this.Bl=0|s[3],this.Ch=0|s[4],this.Cl=0|s[5],this.Dh=0|s[6],this.Dl=0|s[7],this.Eh=0|s[8],this.El=0|s[9],this.Fh=0|s[10],this.Fl=0|s[11],this.Gh=0|s[12],this.Gl=0|s[13],this.Hh=0|s[14],this.Hl=0|s[15]}get(){let{Ah:e,Al:t,Bh:r,Bl:o,Ch:i,Cl:n,Dh:s,Dl:a,Eh:d,El:u,Fh:c,Fl:f,Gh:h,Gl:l,Hh:p,Hl:g}=this;return[e,t,r,o,i,n,s,a,d,u,c,f,h,l,p,g]}set(e,t,r,o,i,n,s,a,d,u,c,f,h,l,p,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|o,this.Ch=0|i,this.Cl=0|n,this.Dh=0|s,this.Dl=0|a,this.Eh=0|d,this.El=0|u,this.Fh=0|c,this.Fl=0|f,this.Gh=0|h,this.Gl=0|l,this.Hh=0|p,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)p[r]=e.getUint32(t),g[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){let t=0|p[e-15],r=0|g[e-15],o=rotrSH(t,r,1)^rotrSH(t,r,8)^shrSH(t,r,7),i=rotrSL(t,r,1)^rotrSL(t,r,8)^shrSL(t,r,7),n=0|p[e-2],s=0|g[e-2],a=rotrSH(n,s,19)^rotrBH(n,s,61)^shrSH(n,s,6),d=rotrSL(n,s,19)^rotrBL(n,s,61)^shrSL(n,s,6),u=add4L(i,d,g[e-7],g[e-16]),c=add4H(u,o,a,p[e-7],p[e-16]);p[e]=0|c,g[e]=0|u}let{Ah:r,Al:o,Bh:i,Bl:n,Ch:s,Cl:a,Dh:d,Dl:u,Eh:c,El:f,Fh:y,Fl:m,Gh:E,Gl:b,Hh:x,Hl:w}=this;for(let e=0;e<80;e++){let t=rotrSH(c,f,14)^rotrSH(c,f,18)^rotrBH(c,f,41),C=rotrSL(c,f,14)^rotrSL(c,f,18)^rotrBL(c,f,41),B=c&y^~c&E,I=f&m^~f&b,P=add5L(w,C,I,l[e],g[e]),v=add5H(P,x,t,B,h[e],p[e]),A=0|P,O=rotrSH(r,o,28)^rotrBH(r,o,34)^rotrBH(r,o,39),L=rotrSL(r,o,28)^rotrBL(r,o,34)^rotrBL(r,o,39),R=r&i^r&s^i&s,S=o&n^o&a^n&a;x=0|E,w=0|b,E=0|y,b=0|m,y=0|c,m=0|f,({h:c,l:f}=add(0|d,0|u,0|v,0|A)),d=0|s,u=0|a,s=0|i,a=0|n,i=0|r,n=0|o;let _=add3L(A,L,S);r=add3H(_,v,O,R),o=0|_}({h:r,l:o}=add(0|this.Ah,0|this.Al,0|r,0|o)),({h:i,l:n}=add(0|this.Bh,0|this.Bl,0|i,0|n)),({h:s,l:a}=add(0|this.Ch,0|this.Cl,0|s,0|a)),({h:d,l:u}=add(0|this.Dh,0|this.Dl,0|d,0|u)),({h:c,l:f}=add(0|this.Eh,0|this.El,0|c,0|f)),({h:y,l:m}=add(0|this.Fh,0|this.Fl,0|y,0|m)),({h:E,l:b}=add(0|this.Gh,0|this.Gl,0|E,0|b)),({h:x,l:w}=add(0|this.Hh,0|this.Hl,0|x,0|w)),this.set(r,o,i,n,s,a,d,u,c,f,y,m,E,b,x,w)}roundClean(){(0,o.ru)(p,g)}destroy(){(0,o.ru)(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};let y=(0,o.V1)(()=>new SHA256),m=(0,o.V1)(()=>new SHA224),E=(0,o.V1)(()=>new SHA512)},1947:(e,t,r)=>{r.d(t,{kb:()=>Hash,gk:()=>abytes,$h:()=>aexists,k8:()=>anumber,eB:()=>aoutput,ci:()=>bytesToHex,ru:()=>clean,eV:()=>concatBytes,V1:()=>createHasher,GL:()=>createView,nr:()=>hexToBytes,_t:()=>isBytes,O6:()=>randomBytes,np:()=>rotr,O0:()=>toBytes,iY:()=>utf8ToBytes});var o=r(6005),i=r.t(o,2);let n=i&&"object"==typeof i&&"webcrypto"in i?o.webcrypto:i&&"object"==typeof i&&"randomBytes"in i?i:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function anumber(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, got "+e)}function abytes(e,...t){if(!isBytes(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function aexists(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function aoutput(e,t){abytes(e);let r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}function clean(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function createView(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function rotr(e,t){return e<<32-t|e>>>t}let s="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,a=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex(e){if(abytes(e),s)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=a[e[r]];return t}let d={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(e){return e>=d._0&&e<=d._9?e-d._0:e>=d.A&&e<=d.F?e-(d.A-10):e>=d.a&&e<=d.f?e-(d.a-10):void 0}function hexToBytes(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);if(s)return Uint8Array.fromHex(e);let t=e.length,r=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);let o=new Uint8Array(r);for(let t=0,i=0;t<r;t++,i+=2){let r=asciiToBase16(e.charCodeAt(i)),n=asciiToBase16(e.charCodeAt(i+1));if(void 0===r||void 0===n){let t=e[i]+e[i+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+i)}o[t]=16*r+n}return o}function utf8ToBytes(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function toBytes(e){return"string"==typeof e&&(e=utf8ToBytes(e)),abytes(e),e}function concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){let o=e[r];abytes(o),t+=o.length}let r=new Uint8Array(t);for(let t=0,o=0;t<e.length;t++){let i=e[t];r.set(i,o),o+=i.length}return r}let Hash=class Hash{};function createHasher(e){let hashC=t=>e().update(toBytes(t)).digest(),t=e();return hashC.outputLen=t.outputLen,hashC.blockLen=t.blockLen,hashC.create=()=>e(),hashC}function randomBytes(e=32){if(n&&"function"==typeof n.getRandomValues)return n.getRandomValues(new Uint8Array(e));if(n&&"function"==typeof n.randomBytes)return Uint8Array.from(n.randomBytes(e));throw Error("crypto.getRandomValues must be defined")}}};