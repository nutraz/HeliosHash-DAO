import { AuthClient } from "@dfinity/auth-client";
import { Actor, HttpAgent, Identity } from "@dfinity/agent";

let authClient: AuthClient | null = null;

export async function getAuthClient(): Promise<AuthClient> {
  if (!authClient) {
    authClient = await AuthClient.create();
  }
  return authClient;
}

export async function connect(identityProvider = "http://localhost:8000") {
  const ac = await getAuthClient();
  await ac.login({
    identityProvider,
    onSuccess: () => {}
  });
  const identity = await ac.getIdentity();
  return identity.getPrincipal().toString();
}

export async function disconnect() {
  const ac = await getAuthClient();
  await ac.logout();
}

export async function getIdentity(): Promise<Identity | null> {
  const ac = await getAuthClient();
  try {
    const id = await ac.getIdentity();
    return id;
  } catch (e) {
    return null;
  }
}

export async function actorFor<T>(idlFactory: any, canisterId: string) : Promise<T> {
  const identity = await getIdentity();
  const agent = new HttpAgent({ identity: identity as any });
  try {
    // For local replica, fetch root key
    agent.fetchRootKey();
  } catch (e) {
    // ignore in prod
  }
  const actor = Actor.createActor(idlFactory, { agent, canisterId }) as unknown as T;
  return actor;
}

export async function getPrincipalText(): Promise<string | null> {
  const id = await getIdentity();
  if (!id) return null;
  return id.getPrincipal().toString();
}

export async function getGovernanceActor() {
  try {
    // This import is generated by `dfx generate` and exists under `.dfx/local/canisters/...`
    // It may not be present in CI or before running `dfx generate` â€” handle gracefully.
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const mod = await import("../../../.dfx/local/canisters/governance");
    const { idlFactory: governanceIDL, canisterId: governanceId } = mod as any;
    const identity = await getIdentity();
    const agent = new HttpAgent({ identity: identity as any });
    try { agent.fetchRootKey(); } catch (e) {}
    const governance = Actor.createActor(governanceIDL, { agent, canisterId: governanceId });
    return governance;
  } catch (e) {
    // Not generated yet or cannot load; return null so callers can fallback.
    return null;
  }
}

export default {
  getAuthClient,
  connect,
  disconnect,
  getIdentity,
  actorFor,
  getPrincipalText,
  getGovernanceActor,
};
