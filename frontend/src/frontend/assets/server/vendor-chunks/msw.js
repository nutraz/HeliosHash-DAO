"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msw";
exports.ids = ["vendor-chunks/msw"];
exports.modules = {

/***/ "(ssr)/../../node_modules/msw/lib/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/msw/lib/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  SetupApi: () => SetupApi,\n  SetupWorkerApi: () => SetupWorkerApi,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/context/index.ts\nvar context_exports = {};\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n});\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nvar import_headers_polyfill = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nvar cookieUtils = __toESM(__webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\"));\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nvar import_is_node_process = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.js\");\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case \"real\": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nvar import_is_node_process2 = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.js\");\nvar import_headers_polyfill2 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__webpack_require__(/*! node-fetch */ \"(ssr)/../../node_modules/node-fetch/lib/index.js\"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/internal/checkGlobals.ts\nvar import_outvariant2 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\n\n// src/utils/internal/devUtils.ts\nvar import_outvariant = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/checkGlobals.ts\nfunction checkGlobals() {\n  (0, import_outvariant2.invariant)(\n    typeof URL !== \"undefined\",\n    devUtils.formatMessage(\n      `Global \"URL\" class is not defined. This likely means that you're running MSW in an environment that doesn't support all Node.js standard API (e.g. React Native). If that's the case, please use an appropriate polyfill for the \"URL\" class, like \"react-native-url-polyfill\".`\n    )\n  );\n}\n\n// src/setupWorker/setupWorker.ts\nvar import_outvariant5 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar import_is_node_process3 = __webpack_require__(/*! is-node-process */ \"(ssr)/../../node_modules/is-node-process/lib/index.js\");\n\n// src/setupWorker/start/createStartHandler.ts\nvar import_until4 = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar import_until = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting\n  ];\n  const relevantStates = allStates.filter((state) => {\n    return state != null;\n  });\n  const worker = relevantStates.find((worker2) => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/utils/url/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async (url, options = {}, findWorker) => {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(\n    (registrations) => registrations.filter(\n      (registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)\n    )\n  );\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker\n        ),\n        existingRegistration\n      ];\n    });\n  }\n  const [error2, instance] = await (0, import_until.until)(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options);\n      return [\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration\n      ];\n    }\n  );\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(\n        devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`)\n      );\n    }\n    throw new Error(\n      devUtils.formatMessage(\n        \"Failed to register the Service Worker:\\n\\n%s\",\n        error2.message\n      )\n    );\n  }\n  return instance;\n};\n\n// src/setupWorker/start/utils/printStartMessage.ts\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n  console.log(\n    \"%cDocumentation: %chttps://mswjs.io/docs\",\n    \"font-weight:bold\",\n    \"font-weight:normal\"\n  );\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  var _a, _b;\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`\n    );\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n}\n\n// src/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event, ...rest2) {\n    const [data2, transfer] = rest2;\n    this.port.postMessage({ type: event, data: data2 }, { transfer });\n  }\n};\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nvar import_interceptors2 = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_headers_polyfill5 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/request/MockedRequest.ts\nvar cookieUtils3 = __toESM(__webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\"));\nvar import_cookies = __webpack_require__(/*! @mswjs/cookies */ \"(ssr)/../../node_modules/@mswjs/cookies/lib/index.js\");\nvar import_interceptors = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_bufferUtils = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js\");\nvar import_headers_polyfill4 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/request/getRequestCookies.ts\nvar cookieUtils2 = __toESM(__webpack_require__(/*! cookie */ \"(ssr)/../../node_modules/cookie/index.js\"));\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case \"include\": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nvar import_headers_polyfill3 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith(\"boundary=\")).map((s) => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = import_cookies.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers\n  });\n}\n\n// src/utils/handleRequest.ts\nvar import_until2 = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar import_js_levenshtein = __toESM(__webpack_require__(/*! js-levenshtein */ \"(ssr)/../../node_modules/js-levenshtein/index.js\"));\n\n// src/utils/internal/parseGraphQLRequest.ts\nvar import_graphql = __webpack_require__(/*! graphql */ \"(ssr)/../../node_modules/graphql/index.js\");\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\": {\n      const query = request.url.searchParams.get(\"query\");\n      const variables = request.url.searchParams.get(\"variables\") || \"\";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case \"POST\": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || \"\") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\nvar import_headers_polyfill6 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\nvar import_path_to_regexp = __webpack_require__(/*! path-to-regexp */ \"(ssr)/../../node_modules/path-to-regexp/dist/index.js\");\nvar import_getCleanUrl = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js\");\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = \"(.*)\";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nvar import_headers_polyfill8 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/response.ts\nvar import_headers_polyfill7 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new import_headers_polyfill7.Headers({\n          \"x-powered-by\": \"msw\"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar RESTMethods = /* @__PURE__ */ ((RESTMethods2) => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s %s (%c%s%c)\"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nvar import_outvariant3 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant3.invariant)(\n    fieldName.trim() !== \"\",\n    devUtils.formatMessage(\n      \"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"data\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"errors\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== \"extensions\",\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request[\"_body\"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : \"\"\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation()\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage(\"%s %s (%c%s%c)\"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      \"color:inherit\"\n    );\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\": {\n        devUtils.error(\"Error: %s\", message);\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'\n          )\n        );\n      }\n      case \"warn\": {\n        devUtils.warn(\"Warning: %s\", message);\n        break;\n      }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nvar import_cookies2 = __webpack_require__(/*! @mswjs/cookies */ \"(ssr)/../../node_modules/@mswjs/cookies/lib/index.js\");\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add({ ...request, url: request.url.toString() }, response2);\n  import_cookies2.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/utils/logging/serializeResponse.ts\nvar import_headers_polyfill9 = __webpack_require__(/*! headers-polyfill */ \"(ssr)/../../node_modules/headers-polyfill/lib/index.js\");\nasync function serializeResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(response2.headers)),\n    body: await response2.clone().text()\n  };\n}\n\n// src/setupWorker/start/createRequestListener.ts\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    var _a;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n    try {\n      await handleRequest(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage(\"NOT_FOUND\");\n          },\n          async onMockedResponse(response2, { handler, publicRequest, parsedRequest }) {\n            if (response2.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'\n                )\n              );\n            }\n            const responseInstance = new Response(response2.body, response2);\n            const responseForLogs = responseInstance.clone();\n            const responseBodyBuffer = await responseInstance.arrayBuffer();\n            const responseBody = response2.body == null ? null : responseBodyBuffer;\n            messageChannel.postMessage(\n              \"MOCK_RESPONSE\",\n              {\n                ...response2,\n                body: responseBody\n              },\n              [responseBodyBuffer]\n            );\n            if (!options.quiet) {\n              context.emitter.once(\"response:mocked\", async () => {\n                handler.log(\n                  publicRequest,\n                  await serializeResponse(responseForLogs),\n                  parsedRequest\n                );\n              });\n            }\n          }\n        }\n      );\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n      if (error2 instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          (_a = error2.stack) != null ? _a : error2\n        );\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n}\n\n// src/utils/internal/requestIntegrityCheck.ts\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const { payload: actualChecksum } = await context.events.once(\n    \"INTEGRITY_CHECK_RESPONSE\"\n  );\n  if (actualChecksum !== \"3d6b9f06410d179a7f7404d4bf4c3c70\") {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"3d6b9f06410d179a7f7404d4bf4c3c70\"}).`\n    );\n  }\n  return serviceWorker;\n}\n\n// src/utils/deferNetworkRequestsUntil.ts\nvar import_until3 = __webpack_require__(/*! @open-draft/until */ \"(ssr)/../../node_modules/@open-draft/until/lib/index.js\");\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function(...args) {\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = async (...args) => {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...args);\n  };\n}\n\n// src/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const { payload: responseJson } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n}\n\n// src/setupWorker/start/utils/validateWorkerScope.ts\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`\n    );\n  }\n}\n\n// src/setupWorker/start/createStartHandler.ts\nvar createStartHandler = (context) => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\n        \"REQUEST\",\n        createRequestListener(context, options)\n      );\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker\n      );\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(\n          `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n          options.serviceWorker.url\n        ) : devUtils.formatMessage(\n          `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n          options.serviceWorker.url,\n          location.host\n        );\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(\n        () => requestIntegrityCheck(context, worker)\n      );\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send(\"KEEPALIVE_REQUEST\"),\n        5e3\n      );\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting;\n        if (pendingInstance) {\n          await new Promise((resolve) => {\n            pendingInstance.addEventListener(\"statechange\", () => {\n              if (pendingInstance.state === \"activated\") {\n                return resolve();\n              }\n            });\n          });\n        }\n        await enableMocking(context, options).catch((error2) => {\n          throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n        });\n        return registration;\n      }\n    );\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/setupWorker/stop/utils/printStopMessage.ts\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(\n    `%c${devUtils.formatMessage(\"Mocking disabled.\")}`,\n    \"color:orangered;font-weight:bold;\"\n  );\n}\n\n// src/setupWorker/stop/createStop.ts\nvar createStop = (context) => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.'\n      );\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({ quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet });\n  };\n};\n\n// src/setupWorker/start/utils/prepareStartHandler.ts\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nvar import_interceptors3 = __webpack_require__(/*! @mswjs/interceptors */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/index.js\");\nvar import_fetch3 = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js\");\nvar import_XMLHttpRequest = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest */ \"(ssr)/../../node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\");\n\n// src/utils/request/createResponseFromIsomorphicResponse.ts\nfunction createResponseFromIsomorphicResponse(response2) {\n  return new Response(response2.body, {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers\n  });\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors3.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer()\n    });\n    const response2 = await handleRequest(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", async (response3) => {\n              handler.log(\n                publicRequest,\n                await serializeResponse(response3),\n                parsedRequest\n              );\n            });\n          }\n        }\n      }\n    );\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on(\"response\", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n    if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", browserResponse, request.id);\n    } else {\n      context.emitter.emit(\"response:bypass\", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options\n    );\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({ quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet });\n  };\n}\n\n// src/SetupApi.ts\nvar import_outvariant4 = __webpack_require__(/*! outvariant */ \"(ssr)/../../node_modules/outvariant/lib/index.js\");\nvar import_strict_event_emitter = __webpack_require__(/*! strict-event-emitter */ \"(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/index.js\");\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new import_strict_event_emitter.Emitter();\n    this.publicEmitter = new import_strict_event_emitter.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0, import_outvariant4.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class extends SetupApi {\n  constructor(...handlers) {\n    super(...handlers);\n    this.startHandler = null;\n    this.stopHandler = null;\n    (0, import_outvariant5.invariant)(\n      !(0, import_is_node_process3.isNodeProcess)(),\n      devUtils.formatMessage(\n        \"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"\n      )\n    );\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(\n            navigator.serviceWorker,\n            \"message\",\n            (event) => {\n              if (event.source !== this.context.worker) {\n                return;\n              }\n              const message = event.data;\n              if (!message) {\n                return;\n              }\n              if (message.type === eventType) {\n                callback(event, message);\n              }\n            }\n          );\n        },\n        send: (type) => {\n          var _a;\n          (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({ eventType, target, callback });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: (eventType) => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = (event) => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"message\",\n                handleIncomingMessage\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                \"messageerror\",\n                reject\n              )\n            );\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind());\n          });\n        }\n      },\n      useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n    };\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers\n      }\n    });\n    this.startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  async start(options = {}) {\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options\n    );\n    return await this.startHandler(this.context.startOptions, options);\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.groupCollapsed(`${pragma} ${header}`);\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`);\n      }\n      console.log(\"Handler:\", handler);\n      console.groupEnd();\n    });\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\n\n// src/rest.ts\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\" /* HEAD */),\n  get: createRestHandler(\"GET\" /* GET */),\n  post: createRestHandler(\"POST\" /* POST */),\n  put: createRestHandler(\"PUT\" /* PUT */),\n  delete: createRestHandler(\"DELETE\" /* DELETE */),\n  patch: createRestHandler(\"PATCH\" /* PATCH */),\n  options: createRestHandler(\"OPTIONS\" /* OPTIONS */)\n};\n\n// src/graphql.ts\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(\n      operationType,\n      operationName,\n      url,\n      resolver\n    );\n  };\n}\nfunction createGraphQLOperationHandler(url) {\n  return (resolver) => {\n    return new GraphQLHandler(\n      \"all\",\n      new RegExp(\".*\"),\n      url,\n      resolver\n    );\n  };\n}\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(\"query\", \"*\"),\n  mutation: createScopedGraphQLHandler(\"mutation\", \"*\")\n};\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(\"query\", url),\n    mutation: createScopedGraphQLHandler(\"mutation\", url)\n  };\n}\nvar graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink\n};\n\n// src/index.ts\ncheckGlobals();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLGdGQUFrQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQXNCTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsaW9zaGFzaC13ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9saWIvaW5kZXguanM/OWE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgR3JhcGhRTEhhbmRsZXI6ICgpID0+IEdyYXBoUUxIYW5kbGVyLFxuICBNb2NrZWRSZXF1ZXN0OiAoKSA9PiBNb2NrZWRSZXF1ZXN0LFxuICBSRVNUTWV0aG9kczogKCkgPT4gUkVTVE1ldGhvZHMsXG4gIFJlcXVlc3RIYW5kbGVyOiAoKSA9PiBSZXF1ZXN0SGFuZGxlcixcbiAgUmVzdEhhbmRsZXI6ICgpID0+IFJlc3RIYW5kbGVyLFxuICBTZXR1cEFwaTogKCkgPT4gU2V0dXBBcGksXG4gIFNldHVwV29ya2VyQXBpOiAoKSA9PiBTZXR1cFdvcmtlckFwaSxcbiAgY2xlYW5Vcmw6ICgpID0+IGNsZWFuVXJsLFxuICBjb21wb3NlOiAoKSA9PiBjb21wb3NlLFxuICBjb250ZXh0OiAoKSA9PiBjb250ZXh0X2V4cG9ydHMsXG4gIGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb246ICgpID0+IGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24sXG4gIGRlZmF1bHRDb250ZXh0OiAoKSA9PiBkZWZhdWx0Q29udGV4dCxcbiAgZGVmYXVsdFJlc3BvbnNlOiAoKSA9PiBkZWZhdWx0UmVzcG9uc2UsXG4gIGdyYXBocWw6ICgpID0+IGdyYXBocWwsXG4gIGdyYXBocWxDb250ZXh0OiAoKSA9PiBncmFwaHFsQ29udGV4dCxcbiAgaGFuZGxlUmVxdWVzdDogKCkgPT4gaGFuZGxlUmVxdWVzdCxcbiAgbWF0Y2hSZXF1ZXN0VXJsOiAoKSA9PiBtYXRjaFJlcXVlc3RVcmwsXG4gIHJlc3BvbnNlOiAoKSA9PiByZXNwb25zZSxcbiAgcmVzdDogKCkgPT4gcmVzdCxcbiAgcmVzdENvbnRleHQ6ICgpID0+IHJlc3RDb250ZXh0LFxuICBzZXR1cFdvcmtlcjogKCkgPT4gc2V0dXBXb3JrZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvY29udGV4dC9pbmRleC50c1xudmFyIGNvbnRleHRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29udGV4dF9leHBvcnRzLCB7XG4gIGJvZHk6ICgpID0+IGJvZHksXG4gIGNvb2tpZTogKCkgPT4gY29va2llLFxuICBkYXRhOiAoKSA9PiBkYXRhLFxuICBkZWxheTogKCkgPT4gZGVsYXksXG4gIGVycm9yczogKCkgPT4gZXJyb3JzLFxuICBleHRlbnNpb25zOiAoKSA9PiBleHRlbnNpb25zLFxuICBmZXRjaDogKCkgPT4gZmV0Y2gsXG4gIGpzb246ICgpID0+IGpzb24sXG4gIHNldDogKCkgPT4gc2V0LFxuICBzdGF0dXM6ICgpID0+IHN0YXR1cyxcbiAgdGV4dDogKCkgPT4gdGV4dCxcbiAgeG1sOiAoKSA9PiB4bWxcbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjEvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2NvZGVzLmpzb25cbnZhciBjb2Rlc19kZWZhdWx0ID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIxMDNcIjogXCJFYXJseSBIaW50c1wiLFxuICBcIjIwMFwiOiBcIk9LXCIsXG4gIFwiMjAxXCI6IFwiQ3JlYXRlZFwiLFxuICBcIjIwMlwiOiBcIkFjY2VwdGVkXCIsXG4gIFwiMjAzXCI6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgXCIyMDRcIjogXCJObyBDb250ZW50XCIsXG4gIFwiMjA1XCI6IFwiUmVzZXQgQ29udGVudFwiLFxuICBcIjIwNlwiOiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICBcIjIwN1wiOiBcIk11bHRpLVN0YXR1c1wiLFxuICBcIjIwOFwiOiBcIkFscmVhZHkgUmVwb3J0ZWRcIixcbiAgXCIyMjZcIjogXCJJTSBVc2VkXCIsXG4gIFwiMzAwXCI6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICBcIjMwMVwiOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gIFwiMzAyXCI6IFwiRm91bmRcIixcbiAgXCIzMDNcIjogXCJTZWUgT3RoZXJcIixcbiAgXCIzMDRcIjogXCJOb3QgTW9kaWZpZWRcIixcbiAgXCIzMDVcIjogXCJVc2UgUHJveHlcIixcbiAgXCIzMDdcIjogXCJUZW1wb3JhcnkgUmVkaXJlY3RcIixcbiAgXCIzMDhcIjogXCJQZXJtYW5lbnQgUmVkaXJlY3RcIixcbiAgXCI0MDBcIjogXCJCYWQgUmVxdWVzdFwiLFxuICBcIjQwMVwiOiBcIlVuYXV0aG9yaXplZFwiLFxuICBcIjQwMlwiOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgXCI0MDNcIjogXCJGb3JiaWRkZW5cIixcbiAgXCI0MDRcIjogXCJOb3QgRm91bmRcIixcbiAgXCI0MDVcIjogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgXCI0MDZcIjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICBcIjQwN1wiOiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDA4XCI6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gIFwiNDA5XCI6IFwiQ29uZmxpY3RcIixcbiAgXCI0MTBcIjogXCJHb25lXCIsXG4gIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gIFwiNDEyXCI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICBcIjQxM1wiOiBcIlBheWxvYWQgVG9vIExhcmdlXCIsXG4gIFwiNDE0XCI6IFwiVVJJIFRvbyBMb25nXCIsXG4gIFwiNDE1XCI6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICBcIjQxNlwiOiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiLFxuICBcIjQxN1wiOiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICBcIjQxOFwiOiBcIkknbSBhIFRlYXBvdFwiLFxuICBcIjQyMVwiOiBcIk1pc2RpcmVjdGVkIFJlcXVlc3RcIixcbiAgXCI0MjJcIjogXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiLFxuICBcIjQyM1wiOiBcIkxvY2tlZFwiLFxuICBcIjQyNFwiOiBcIkZhaWxlZCBEZXBlbmRlbmN5XCIsXG4gIFwiNDI1XCI6IFwiVG9vIEVhcmx5XCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufTtcblxuLy8gc3JjL2NvbnRleHQvc3RhdHVzLnRzXG52YXIgc3RhdHVzID0gKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuc3RhdHVzID0gc3RhdHVzQ29kZTtcbiAgICByZXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgY29kZXNfZGVmYXVsdFtTdHJpbmcoc3RhdHVzQ29kZSldO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9zZXQudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbCA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuZnVuY3Rpb24gc2V0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXJncztcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlcy5oZWFkZXJzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSAoMCwgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwub2JqZWN0VG9IZWFkZXJzKShuYW1lKTtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUyLCBuYW1lMikgPT4ge1xuICAgICAgICByZXMuaGVhZGVycy5hcHBlbmQobmFtZTIsIHZhbHVlMik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuLy8gc3JjL2NvbnRleHQvY29va2llLnRzXG52YXIgY29va2llVXRpbHMgPSBfX3RvRVNNKHJlcXVpcmUoXCJjb29raWVcIikpO1xudmFyIGNvb2tpZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRDb29raWUgPSBjb29raWVVdGlscy5zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIHJlcy5oZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgc2VyaWFsaXplZENvb2tpZSk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZG9jdW1lbnQuY29va2llID0gc2VyaWFsaXplZENvb2tpZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2JvZHkudHNcbnZhciBib2R5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmJvZHkgPSB2YWx1ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2pzb25QYXJzZS50c1xuZnVuY3Rpb24ganNvblBhcnNlKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9pc09iamVjdC50c1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL21lcmdlUmlnaHQudHNcbmZ1bmN0aW9uIG1lcmdlUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHJpZ2h0KS5yZWR1Y2UoKHJlc3VsdCwgW2tleSwgcmlnaHRWYWx1ZV0pID0+IHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSByZXN1bHRba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsZWZ0VmFsdWUpICYmIEFycmF5LmlzQXJyYXkocmlnaHRWYWx1ZSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbGVmdFZhbHVlLmNvbmNhdChyaWdodFZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChsZWZ0VmFsdWUpICYmIGlzT2JqZWN0KHJpZ2h0VmFsdWUpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlUmlnaHQobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdFtrZXldID0gcmlnaHRWYWx1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBPYmplY3QuYXNzaWduKHt9LCBsZWZ0KSk7XG59XG5cbi8vIHNyYy9jb250ZXh0L2pzb24udHNcbnZhciBqc29uID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICByZXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkyKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZGF0YS50c1xudmFyIGRhdGEgPSAocGF5bG9hZCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZGF0YTogcGF5bG9hZCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2V4dGVuc2lvbnMudHNcbnZhciBleHRlbnNpb25zID0gKHBheWxvYWQpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGV4dGVuc2lvbnM6IHBheWxvYWQgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9kZWxheS50c1xudmFyIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MgPSByZXF1aXJlKFwiaXMtbm9kZS1wcm9jZXNzXCIpO1xudmFyIFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVCA9IDIxNDc0ODM2NDc7XG52YXIgTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FID0gMTAwO1xudmFyIE1BWF9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDQwMDtcbnZhciBOT0RFX1NFUlZFUl9SRVNQT05TRV9USU1FID0gNTtcbnZhciBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUgPSAoKSA9PiB7XG4gIGlmICgoMCwgaW1wb3J0X2lzX25vZGVfcHJvY2Vzcy5pc05vZGVQcm9jZXNzKSgpKSB7XG4gICAgcmV0dXJuIE5PREVfU0VSVkVSX1JFU1BPTlNFX1RJTUU7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgTWF0aC5yYW5kb20oKSAqIChNQVhfU0VSVkVSX1JFU1BPTlNFX1RJTUUgLSBNSU5fU0VSVkVSX1JFU1BPTlNFX1RJTUUpICsgTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FXG4gICk7XG59O1xudmFyIGRlbGF5ID0gKGR1cmF0aW9uT3JNb2RlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgbGV0IGRlbGF5VGltZTtcbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uT3JNb2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzd2l0Y2ggKGR1cmF0aW9uT3JNb2RlKSB7XG4gICAgICAgIGNhc2UgXCJpbmZpbml0ZVwiOiB7XG4gICAgICAgICAgZGVsYXlUaW1lID0gU0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZWFsXCI6IHtcbiAgICAgICAgICBkZWxheVRpbWUgPSBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBkZWxheSBhIHJlc3BvbnNlOiB1bmtub3duIGRlbGF5IG1vZGUgXCIke2R1cmF0aW9uT3JNb2RlfVwiLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBwcm92aWRlIG9uZSBvZiB0aGUgc3VwcG9ydGVkIG1vZGVzIChcInJlYWxcIiwgXCJpbmZpbml0ZVwiKSBvciBhIG51bWJlciB0byBcImN0eC5kZWxheVwiLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25Pck1vZGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRlbGF5VGltZSA9IGdldFJhbmRvbVNlcnZlclJlc3BvbnNlVGltZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHVyYXRpb25Pck1vZGUgPiBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZGVsYXkgYSByZXNwb25zZTogcHJvdmlkZWQgZGVsYXkgZHVyYXRpb24gKCR7ZHVyYXRpb25Pck1vZGV9KSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgZHVyYXRpb24gZm9yIFwic2V0VGltZW91dFwiICgke1NFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVH0pLiBUaGlzIHdpbGwgY2F1c2UgdGhlIHJlc3BvbnNlIHRvIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5LiBQbGVhc2UgdXNlIGEgbnVtYmVyIHdpdGhpbiB0aGUgYWxsb3dlZCByYW5nZSB0byBkZWxheSB0aGUgcmVzcG9uc2UgYnkgZXhhY3QgZHVyYXRpb24sIG9yIGNvbnNpZGVyIHRoZSBcImluZmluaXRlXCIgZGVsYXkgbW9kZSB0byBkZWxheSB0aGUgcmVzcG9uc2UgaW5kZWZpbml0ZWx5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlbGF5VGltZSA9IGR1cmF0aW9uT3JNb2RlO1xuICAgIH1cbiAgICByZXMuZGVsYXkgPSBkZWxheVRpbWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2Vycm9ycy50c1xudmFyIGVycm9ycyA9IChlcnJvcnNMaXN0KSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgaWYgKGVycm9yc0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBlcnJvcnM6IGVycm9yc0xpc3QgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9mZXRjaC50c1xudmFyIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MyID0gcmVxdWlyZShcImlzLW5vZGUtcHJvY2Vzc1wiKTtcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDIgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbnZhciB1c2VGZXRjaCA9ICgwLCBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzMi5pc05vZGVQcm9jZXNzKSgpID8gKGlucHV0LCBpbml0KSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9fdG9FU00ocmVxdWlyZShcIm5vZGUtZmV0Y2hcIikpKS50aGVuKFxuICAoeyBkZWZhdWx0OiBub2RlRmV0Y2ggfSkgPT4gbm9kZUZldGNoKGlucHV0LCBpbml0KVxuKSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgYXVnbWVudFJlcXVlc3RJbml0ID0gKHJlcXVlc3RJbml0KSA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwyLkhlYWRlcnMocmVxdWVzdEluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwieC1tc3ctYnlwYXNzXCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXF1ZXN0SW5pdCxcbiAgICBoZWFkZXJzOiBoZWFkZXJzLmFsbCgpXG4gIH07XG59O1xudmFyIGNyZWF0ZUZldGNoUmVxdWVzdFBhcmFtZXRlcnMgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgeyBib2R5OiBib2R5MiwgbWV0aG9kIH0gPSBpbnB1dDtcbiAgY29uc3QgcmVxdWVzdFBhcmFtZXRlcnMgPSB7XG4gICAgLi4uaW5wdXQsXG4gICAgYm9keTogdm9pZCAwXG4gIH07XG4gIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdFBhcmFtZXRlcnM7XG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5MiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYm9keTIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGJvZHkyID09PSBcImJvb2xlYW5cIikge1xuICAgIHJlcXVlc3RQYXJhbWV0ZXJzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5Mik7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdFBhcmFtZXRlcnMuYm9keSA9IGJvZHkyO1xuICB9XG4gIHJldHVybiByZXF1ZXN0UGFyYW1ldGVycztcbn07XG52YXIgZmV0Y2ggPSAoaW5wdXQsIHJlcXVlc3RJbml0ID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB1c2VGZXRjaChpbnB1dCwgYXVnbWVudFJlcXVlc3RJbml0KHJlcXVlc3RJbml0KSk7XG4gIH1cbiAgY29uc3QgcmVxdWVzdFBhcmFtZXRlcnMgPSBjcmVhdGVGZXRjaFJlcXVlc3RQYXJhbWV0ZXJzKGlucHV0KTtcbiAgY29uc3QgZGVyaXZlZFJlcXVlc3RJbml0ID0gYXVnbWVudFJlcXVlc3RJbml0KHJlcXVlc3RQYXJhbWV0ZXJzKTtcbiAgcmV0dXJuIHVzZUZldGNoKGlucHV0LnVybC5ocmVmLCBkZXJpdmVkUmVxdWVzdEluaXQpO1xufTtcblxuLy8gc3JjL2NvbnRleHQvdGV4dC50c1xudmFyIHRleHQgPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgIHJlcy5ib2R5ID0gYm9keTI7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3htbC50c1xudmFyIHhtbCA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveG1sXCIpO1xuICAgIHJlcy5ib2R5ID0gYm9keTI7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9jaGVja0dsb2JhbHMudHNcbnZhciBpbXBvcnRfb3V0dmFyaWFudDIgPSByZXF1aXJlKFwib3V0dmFyaWFudFwiKTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2RldlV0aWxzLnRzXG52YXIgaW1wb3J0X291dHZhcmlhbnQgPSByZXF1aXJlKFwib3V0dmFyaWFudFwiKTtcbnZhciBMSUJSQVJZX1BSRUZJWCA9IFwiW01TV11cIjtcbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkTWVzc2FnZSA9ICgwLCBpbXBvcnRfb3V0dmFyaWFudC5mb3JtYXQpKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKTtcbiAgcmV0dXJuIGAke0xJQlJBUllfUFJFRklYfSAke2ludGVycG9sYXRlZE1lc3NhZ2V9YDtcbn1cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgY29uc29sZS53YXJuKGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpKTtcbn1cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnNvbGUuZXJyb3IoZm9ybWF0TWVzc2FnZShtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykpO1xufVxudmFyIGRldlV0aWxzID0ge1xuICBmb3JtYXRNZXNzYWdlLFxuICB3YXJuLFxuICBlcnJvclxufTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2NoZWNrR2xvYmFscy50c1xuZnVuY3Rpb24gY2hlY2tHbG9iYWxzKCkge1xuICAoMCwgaW1wb3J0X291dHZhcmlhbnQyLmludmFyaWFudCkoXG4gICAgdHlwZW9mIFVSTCAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgYEdsb2JhbCBcIlVSTFwiIGNsYXNzIGlzIG5vdCBkZWZpbmVkLiBUaGlzIGxpa2VseSBtZWFucyB0aGF0IHlvdSdyZSBydW5uaW5nIE1TVyBpbiBhbiBlbnZpcm9ubWVudCB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBhbGwgTm9kZS5qcyBzdGFuZGFyZCBBUEkgKGUuZy4gUmVhY3QgTmF0aXZlKS4gSWYgdGhhdCdzIHRoZSBjYXNlLCBwbGVhc2UgdXNlIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsIGZvciB0aGUgXCJVUkxcIiBjbGFzcywgbGlrZSBcInJlYWN0LW5hdGl2ZS11cmwtcG9seWZpbGxcIi5gXG4gICAgKVxuICApO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc2V0dXBXb3JrZXIudHNcbnZhciBpbXBvcnRfb3V0dmFyaWFudDUgPSByZXF1aXJlKFwib3V0dmFyaWFudFwiKTtcbnZhciBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzMyA9IHJlcXVpcmUoXCJpcy1ub2RlLXByb2Nlc3NcIik7XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVTdGFydEhhbmRsZXIudHNcbnZhciBpbXBvcnRfdW50aWw0ID0gcmVxdWlyZShcIkBvcGVuLWRyYWZ0L3VudGlsXCIpO1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvZ2V0V29ya2VySW5zdGFuY2UudHNcbnZhciBpbXBvcnRfdW50aWwgPSByZXF1aXJlKFwiQG9wZW4tZHJhZnQvdW50aWxcIik7XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9nZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbi50c1xuZnVuY3Rpb24gZ2V0V29ya2VyQnlSZWdpc3RyYXRpb24ocmVnaXN0cmF0aW9uLCBhYnNvbHV0ZVdvcmtlclVybCwgZmluZFdvcmtlcikge1xuICBjb25zdCBhbGxTdGF0ZXMgPSBbXG4gICAgcmVnaXN0cmF0aW9uLmFjdGl2ZSxcbiAgICByZWdpc3RyYXRpb24uaW5zdGFsbGluZyxcbiAgICByZWdpc3RyYXRpb24ud2FpdGluZ1xuICBdO1xuICBjb25zdCByZWxldmFudFN0YXRlcyA9IGFsbFN0YXRlcy5maWx0ZXIoKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlICE9IG51bGw7XG4gIH0pO1xuICBjb25zdCB3b3JrZXIgPSByZWxldmFudFN0YXRlcy5maW5kKCh3b3JrZXIyKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRXb3JrZXIod29ya2VyMi5zY3JpcHRVUkwsIGFic29sdXRlV29ya2VyVXJsKTtcbiAgfSk7XG4gIHJldHVybiB3b3JrZXIgfHwgbnVsbDtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9nZXRBYnNvbHV0ZVdvcmtlclVybC50c1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVXb3JrZXJVcmwod29ya2VyVXJsKSB7XG4gIHJldHVybiBuZXcgVVJMKHdvcmtlclVybCwgbG9jYXRpb24uaHJlZikuaHJlZjtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2dldFdvcmtlckluc3RhbmNlLnRzXG52YXIgZ2V0V29ya2VySW5zdGFuY2UgPSBhc3luYyAodXJsLCBvcHRpb25zID0ge30sIGZpbmRXb3JrZXIpID0+IHtcbiAgY29uc3QgYWJzb2x1dGVXb3JrZXJVcmwgPSBnZXRBYnNvbHV0ZVdvcmtlclVybCh1cmwpO1xuICBjb25zdCBtb2NrUmVnaXN0cmF0aW9ucyA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmdldFJlZ2lzdHJhdGlvbnMoKS50aGVuKFxuICAgIChyZWdpc3RyYXRpb25zKSA9PiByZWdpc3RyYXRpb25zLmZpbHRlcihcbiAgICAgIChyZWdpc3RyYXRpb24pID0+IGdldFdvcmtlckJ5UmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbiwgYWJzb2x1dGVXb3JrZXJVcmwsIGZpbmRXb3JrZXIpXG4gICAgKVxuICApO1xuICBpZiAoIW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIgJiYgbW9ja1JlZ2lzdHJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG4gIGNvbnN0IFtleGlzdGluZ1JlZ2lzdHJhdGlvbl0gPSBtb2NrUmVnaXN0cmF0aW9ucztcbiAgaWYgKGV4aXN0aW5nUmVnaXN0cmF0aW9uKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUmVnaXN0cmF0aW9uLnVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgZ2V0V29ya2VyQnlSZWdpc3RyYXRpb24oXG4gICAgICAgICAgZXhpc3RpbmdSZWdpc3RyYXRpb24sXG4gICAgICAgICAgYWJzb2x1dGVXb3JrZXJVcmwsXG4gICAgICAgICAgZmluZFdvcmtlclxuICAgICAgICApLFxuICAgICAgICBleGlzdGluZ1JlZ2lzdHJhdGlvblxuICAgICAgXTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBbZXJyb3IyLCBpbnN0YW5jZV0gPSBhd2FpdCAoMCwgaW1wb3J0X3VudGlsLnVudGlsKShcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZWdpc3RyYXRpb24gPSBhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3Rlcih1cmwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgZ2V0V29ya2VyQnlSZWdpc3RyYXRpb24ocmVnaXN0cmF0aW9uLCBhYnNvbHV0ZVdvcmtlclVybCwgZmluZFdvcmtlciksXG4gICAgICAgIHJlZ2lzdHJhdGlvblxuICAgICAgXTtcbiAgICB9XG4gICk7XG4gIGlmIChlcnJvcjIpIHtcbiAgICBjb25zdCBpc1dvcmtlck1pc3NpbmcgPSBlcnJvcjIubWVzc2FnZS5pbmNsdWRlcyhcIig0MDQpXCIpO1xuICAgIGlmIChpc1dvcmtlck1pc3NpbmcpIHtcbiAgICAgIGNvbnN0IHNjb3BlVXJsID0gbmV3IFVSTCgob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zY29wZSkgfHwgXCIvXCIsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKGBGYWlsZWQgdG8gcmVnaXN0ZXIgYSBTZXJ2aWNlIFdvcmtlciBmb3Igc2NvcGUgKCcke3Njb3BlVXJsLmhyZWZ9Jykgd2l0aCBzY3JpcHQgKCcke2Fic29sdXRlV29ya2VyVXJsfScpOiBTZXJ2aWNlIFdvcmtlciBzY3JpcHQgZG9lcyBub3QgZXhpc3QgYXQgdGhlIGdpdmVuIHBhdGguXG5cbkRpZCB5b3UgZm9yZ2V0IHRvIHJ1biBcIm5weCBtc3cgaW5pdCA8UFVCTElDX0RJUj5cIj9cblxuTGVhcm4gbW9yZSBhYm91dCBjcmVhdGluZyB0aGUgU2VydmljZSBXb3JrZXIgc2NyaXB0OiBodHRwczovL21zd2pzLmlvL2RvY3MvY2xpL2luaXRgKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVnaXN0ZXIgdGhlIFNlcnZpY2UgV29ya2VyOlxcblxcbiVzXCIsXG4gICAgICAgIGVycm9yMi5tZXNzYWdlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvcHJpbnRTdGFydE1lc3NhZ2UudHNcbmZ1bmN0aW9uIHByaW50U3RhcnRNZXNzYWdlKGFyZ3MgPSB7fSkge1xuICBpZiAoYXJncy5xdWlldCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtZXNzYWdlID0gYXJncy5tZXNzYWdlIHx8IFwiTW9ja2luZyBlbmFibGVkLlwiO1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgIGAlYyR7ZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShtZXNzYWdlKX1gLFxuICAgIFwiY29sb3I6b3JhbmdlcmVkO2ZvbnQtd2VpZ2h0OmJvbGQ7XCJcbiAgKTtcbiAgY29uc29sZS5sb2coXG4gICAgXCIlY0RvY3VtZW50YXRpb246ICVjaHR0cHM6Ly9tc3dqcy5pby9kb2NzXCIsXG4gICAgXCJmb250LXdlaWdodDpib2xkXCIsXG4gICAgXCJmb250LXdlaWdodDpub3JtYWxcIlxuICApO1xuICBjb25zb2xlLmxvZyhcIkZvdW5kIGFuIGlzc3VlPyBodHRwczovL2dpdGh1Yi5jb20vbXN3anMvbXN3L2lzc3Vlc1wiKTtcbiAgaWYgKGFyZ3Mud29ya2VyVXJsKSB7XG4gICAgY29uc29sZS5sb2coXCJXb3JrZXIgc2NyaXB0IFVSTDpcIiwgYXJncy53b3JrZXJVcmwpO1xuICB9XG4gIGlmIChhcmdzLndvcmtlclNjb3BlKSB7XG4gICAgY29uc29sZS5sb2coXCJXb3JrZXIgc2NvcGU6XCIsIGFyZ3Mud29ya2VyU2NvcGUpO1xuICB9XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2VuYWJsZU1vY2tpbmcudHNcbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZU1vY2tpbmcoY29udGV4dCwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBjb250ZXh0LndvcmtlckNoYW5uZWwuc2VuZChcIk1PQ0tfQUNUSVZBVEVcIik7XG4gIGF3YWl0IGNvbnRleHQuZXZlbnRzLm9uY2UoXCJNT0NLSU5HX0VOQUJMRURcIik7XG4gIGlmIChjb250ZXh0LmlzTW9ja2luZ0VuYWJsZWQpIHtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYEZvdW5kIGEgcmVkdW5kYW50IFwid29ya2VyLnN0YXJ0KClcIiBjYWxsLiBOb3RlIHRoYXQgc3RhcnRpbmcgdGhlIHdvcmtlciB3aGlsZSBtb2NraW5nIGlzIGFscmVhZHkgZW5hYmxlZCB3aWxsIGhhdmUgbm8gZWZmZWN0LiBDb25zaWRlciByZW1vdmluZyB0aGlzIFwid29ya2VyLnN0YXJ0KClcIiBjYWxsLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb250ZXh0LmlzTW9ja2luZ0VuYWJsZWQgPSB0cnVlO1xuICBwcmludFN0YXJ0TWVzc2FnZSh7XG4gICAgcXVpZXQ6IG9wdGlvbnMucXVpZXQsXG4gICAgd29ya2VyU2NvcGU6IChfYSA9IGNvbnRleHQucmVnaXN0cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2NvcGUsXG4gICAgd29ya2VyVXJsOiAoX2IgPSBjb250ZXh0LndvcmtlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNjcmlwdFVSTFxuICB9KTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2NyZWF0ZU1lc3NhZ2VDaGFubmVsLnRzXG52YXIgV29ya2VyQ2hhbm5lbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocG9ydCkge1xuICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gIH1cbiAgcG9zdE1lc3NhZ2UoZXZlbnQsIC4uLnJlc3QyKSB7XG4gICAgY29uc3QgW2RhdGEyLCB0cmFuc2Zlcl0gPSByZXN0MjtcbiAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBldmVudCwgZGF0YTogZGF0YTIgfSwgeyB0cmFuc2ZlciB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL05ldHdvcmtFcnJvci50c1xudmFyIE5ldHdvcmtFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcGFyc2VXb3JrZXJSZXF1ZXN0LnRzXG52YXIgaW1wb3J0X2ludGVyY2VwdG9yczIgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9yc1wiKTtcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDUgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvTW9ja2VkUmVxdWVzdC50c1xudmFyIGNvb2tpZVV0aWxzMyA9IF9fdG9FU00ocmVxdWlyZShcImNvb2tpZVwiKSk7XG52YXIgaW1wb3J0X2Nvb2tpZXMgPSByZXF1aXJlKFwiQG1zd2pzL2Nvb2tpZXNcIik7XG52YXIgaW1wb3J0X2ludGVyY2VwdG9ycyA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzXCIpO1xudmFyIGltcG9ydF9idWZmZXJVdGlscyA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi91dGlscy9idWZmZXJVdGlscy5qc1wiKTtcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDQgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvZ2V0UmVxdWVzdENvb2tpZXMudHNcbnZhciBjb29raWVVdGlsczIgPSBfX3RvRVNNKHJlcXVpcmUoXCJjb29raWVcIikpO1xuZnVuY3Rpb24gZ2V0QWxsQ29va2llcygpIHtcbiAgcmV0dXJuIGNvb2tpZVV0aWxzMi5wYXJzZShkb2N1bWVudC5jb29raWUpO1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdENvb2tpZXMocmVxdWVzdCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBzd2l0Y2ggKHJlcXVlc3QuY3JlZGVudGlhbHMpIHtcbiAgICBjYXNlIFwic2FtZS1vcmlnaW5cIjoge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uLm9yaWdpbiA9PT0gcmVxdWVzdC51cmwub3JpZ2luID8gZ2V0QWxsQ29va2llcygpIDoge307XG4gICAgfVxuICAgIGNhc2UgXCJpbmNsdWRlXCI6IHtcbiAgICAgIHJldHVybiBnZXRBbGxDb29raWVzKCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3BhcnNlTXVsdGlwYXJ0RGF0YS50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsMyA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuZnVuY3Rpb24gcGFyc2VDb250ZW50SGVhZGVycyhoZWFkZXJzU3RyaW5nKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGhlYWRlcnMgPSAoMCwgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwzLnN0cmluZ1RvSGVhZGVycykoaGVhZGVyc1N0cmluZyk7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJ0ZXh0L3BsYWluXCI7XG4gIGNvbnN0IGRpc3Bvc2l0aW9uID0gaGVhZGVycy5nZXQoXCJjb250ZW50LWRpc3Bvc2l0aW9uXCIpO1xuICBpZiAoIWRpc3Bvc2l0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiBoZWFkZXIgaXMgcmVxdWlyZWQuJyk7XG4gIH1cbiAgY29uc3QgZGlyZWN0aXZlcyA9IGRpc3Bvc2l0aW9uLnNwbGl0KFwiO1wiKS5yZWR1Y2UoKGFjYywgY2h1bmspID0+IHtcbiAgICBjb25zdCBbbmFtZTIsIC4uLnJlc3QyXSA9IGNodW5rLnRyaW0oKS5zcGxpdChcIj1cIik7XG4gICAgYWNjW25hbWUyXSA9IHJlc3QyLmpvaW4oXCI9XCIpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgY29uc3QgbmFtZSA9IChfYSA9IGRpcmVjdGl2ZXMubmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgZmlsZW5hbWUgPSAoX2IgPSBkaXJlY3RpdmVzLmZpbGVuYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2xpY2UoMSwgLTEpO1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgZmlsZW5hbWUsXG4gICAgY29udGVudFR5cGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0RGF0YShkYXRhMiwgaGVhZGVycykge1xuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBbLCAuLi5kaXJlY3RpdmVzXSA9IGNvbnRlbnRUeXBlLnNwbGl0KC87ICovKTtcbiAgY29uc3QgYm91bmRhcnkgPSBkaXJlY3RpdmVzLmZpbHRlcigoZCkgPT4gZC5zdGFydHNXaXRoKFwiYm91bmRhcnk9XCIpKS5tYXAoKHMpID0+IHMucmVwbGFjZSgvXmJvdW5kYXJ5PS8sIFwiXCIpKVswXTtcbiAgaWYgKCFib3VuZGFyeSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgYm91bmRhcnlSZWdFeHAgPSBuZXcgUmVnRXhwKGAtLSske2JvdW5kYXJ5fWApO1xuICBjb25zdCBmaWVsZHMgPSBkYXRhMi5zcGxpdChib3VuZGFyeVJlZ0V4cCkuZmlsdGVyKChjaHVuaykgPT4gY2h1bmsuc3RhcnRzV2l0aChcIlxcclxcblwiKSAmJiBjaHVuay5lbmRzV2l0aChcIlxcclxcblwiKSkubWFwKChjaHVuaykgPT4gY2h1bmsudHJpbVN0YXJ0KCkucmVwbGFjZSgvXFxyXFxuJC8sIFwiXCIpKTtcbiAgaWYgKCFmaWVsZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBwYXJzZWRCb2R5ID0ge307XG4gIHRyeSB7XG4gICAgZm9yIChjb25zdCBmaWVsZDIgb2YgZmllbGRzKSB7XG4gICAgICBjb25zdCBbY29udGVudEhlYWRlcnMsIC4uLnJlc3QyXSA9IGZpZWxkMi5zcGxpdChcIlxcclxcblxcclxcblwiKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRCb2R5ID0gcmVzdDIuam9pbihcIlxcclxcblxcclxcblwiKTtcbiAgICAgIGNvbnN0IHsgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlMiwgZmlsZW5hbWUsIG5hbWUgfSA9IHBhcnNlQ29udGVudEhlYWRlcnMoY29udGVudEhlYWRlcnMpO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaWxlbmFtZSA9PT0gdm9pZCAwID8gY29udGVudEJvZHkgOiBuZXcgRmlsZShbY29udGVudEJvZHldLCBmaWxlbmFtZSwgeyB0eXBlOiBjb250ZW50VHlwZTIgfSk7XG4gICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZEJvZHlbbmFtZV07XG4gICAgICBpZiAocGFyc2VkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZWRCb2R5W25hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSBbLi4ucGFyc2VkVmFsdWUsIHZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSBbcGFyc2VkVmFsdWUsIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEJvZHk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcGFyc2VCb2R5LnRzXG5mdW5jdGlvbiBwYXJzZUJvZHkoYm9keTIsIGhlYWRlcnMpIHtcbiAgdmFyIF9hO1xuICBpZiAoIWJvZHkyKSB7XG4gICAgcmV0dXJuIGJvZHkyO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gKChfYSA9IGhlYWRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgfHwgXCJcIjtcbiAgY29uc3QgaGFzTXVsdGlwYXJ0Q29udGVudCA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpO1xuICBpZiAoaGFzTXVsdGlwYXJ0Q29udGVudCAmJiB0eXBlb2YgYm9keTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gcGFyc2VNdWx0aXBhcnREYXRhKGJvZHkyLnRvU3RyaW5nKCksIGhlYWRlcnMpIHx8IGJvZHkyO1xuICB9XG4gIGNvbnN0IGhhc0pzb25Db250ZW50ID0gY29udGVudFR5cGUuaW5jbHVkZXMoXCJqc29uXCIpO1xuICBpZiAoaGFzSnNvbkNvbnRlbnQgJiYgdHlwZW9mIGJvZHkyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGpzb25QYXJzZShib2R5Mi50b1N0cmluZygpKSB8fCBib2R5MjtcbiAgfVxuICByZXR1cm4gYm9keTI7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9pc1N0cmluZ0VxdWFsLnRzXG5mdW5jdGlvbiBpc1N0cmluZ0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgcmV0dXJuIGFjdHVhbC50b0xvd2VyQ2FzZSgpID09PSBleHBlY3RlZC50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9Nb2NrZWRSZXF1ZXN0LnRzXG52YXIgTW9ja2VkUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgaW1wb3J0X2ludGVyY2VwdG9ycy5Jc29tb3JwaGljUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgaW5pdCA9IHt9KSB7XG4gICAgc3VwZXIodXJsLCBpbml0KTtcbiAgICBpZiAoaW5pdC5pZCkge1xuICAgICAgdGhpcy5pZCA9IGluaXQuaWQ7XG4gICAgfVxuICAgIHRoaXMuY2FjaGUgPSBpbml0LmNhY2hlIHx8IFwiZGVmYXVsdFwiO1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSBpbml0LmRlc3RpbmF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlZ3JpdHkgPSBpbml0LmludGVncml0eSB8fCBcIlwiO1xuICAgIHRoaXMua2VlcGFsaXZlID0gaW5pdC5rZWVwYWxpdmUgfHwgZmFsc2U7XG4gICAgdGhpcy5tb2RlID0gaW5pdC5tb2RlIHx8IFwiY29yc1wiO1xuICAgIHRoaXMucHJpb3JpdHkgPSBpbml0LnByaW9yaXR5IHx8IFwiYXV0b1wiO1xuICAgIHRoaXMucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0IHx8IFwiZm9sbG93XCI7XG4gICAgdGhpcy5yZWZlcnJlciA9IGluaXQucmVmZXJyZXIgfHwgXCJcIjtcbiAgICB0aGlzLnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeSB8fCBcIm5vLXJlZmVycmVyXCI7XG4gICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzIHx8IHRoaXMuZ2V0Q29va2llcygpO1xuICB9XG4gIGdldCBib2R5KCkge1xuICAgIGNvbnN0IHRleHQyID0gKDAsIGltcG9ydF9idWZmZXJVdGlscy5kZWNvZGVCdWZmZXIpKHRoaXNbXCJfYm9keVwiXSk7XG4gICAgY29uc3QgYm9keTIgPSBwYXJzZUJvZHkodGV4dDIsIHRoaXMuaGVhZGVycyk7XG4gICAgaWYgKGlzU3RyaW5nRXF1YWwodGhpcy5tZXRob2QsIFwiR0VUXCIpICYmIGJvZHkyID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTI7XG4gIH1cbiAgcGFzc3Rocm91Z2goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogMTAxLFxuICAgICAgc3RhdHVzVGV4dDogXCJDb250aW51ZVwiLFxuICAgICAgaGVhZGVyczogbmV3IGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNC5IZWFkZXJzKCksXG4gICAgICBib2R5OiBudWxsLFxuICAgICAgcGFzc3Rocm91Z2g6IHRydWUsXG4gICAgICBvbmNlOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgZ2V0Q29va2llcygpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVxdWVzdENvb2tpZXNTdHJpbmcgPSB0aGlzLmhlYWRlcnMuZ2V0KFwiY29va2llXCIpO1xuICAgIGNvbnN0IG93bkNvb2tpZXMgPSByZXF1ZXN0Q29va2llc1N0cmluZyA/IGNvb2tpZVV0aWxzMy5wYXJzZShyZXF1ZXN0Q29va2llc1N0cmluZykgOiB7fTtcbiAgICBpbXBvcnRfY29va2llcy5zdG9yZS5oeWRyYXRlKCk7XG4gICAgY29uc3QgY29va2llc0Zyb21TdG9yZSA9IEFycmF5LmZyb20oXG4gICAgICAoX2EgPSBpbXBvcnRfY29va2llcy5zdG9yZS5nZXQoeyAuLi50aGlzLCB1cmw6IHRoaXMudXJsLmhyZWYgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbnRyaWVzKClcbiAgICApLnJlZHVjZSgoY29va2llcywgW25hbWUsIHsgdmFsdWUgfV0pID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNvb2tpZXMsIHsgW25hbWUudHJpbSgpXTogdmFsdWUgfSk7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGNvb2tpZXNGcm9tRG9jdW1lbnQgPSBnZXRSZXF1ZXN0Q29va2llcyh0aGlzKTtcbiAgICBjb25zdCBmb3J3YXJkZWRDb29raWVzID0ge1xuICAgICAgLi4uY29va2llc0Zyb21Eb2N1bWVudCxcbiAgICAgIC4uLmNvb2tpZXNGcm9tU3RvcmVcbiAgICB9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3J3YXJkZWRDb29raWVzKSkge1xuICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZChcImNvb2tpZVwiLCBgJHtuYW1lfT0ke3ZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9yd2FyZGVkQ29va2llcyxcbiAgICAgIC4uLm93bkNvb2tpZXNcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9wYXJzZVdvcmtlclJlcXVlc3QudHNcbmZ1bmN0aW9uIHBhcnNlV29ya2VyUmVxdWVzdChyYXdSZXF1ZXN0KSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmF3UmVxdWVzdC51cmwpO1xuICBjb25zdCBoZWFkZXJzID0gbmV3IGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNS5IZWFkZXJzKHJhd1JlcXVlc3QuaGVhZGVycyk7XG4gIHJldHVybiBuZXcgTW9ja2VkUmVxdWVzdCh1cmwsIHtcbiAgICAuLi5yYXdSZXF1ZXN0LFxuICAgIGJvZHk6ICgwLCBpbXBvcnRfaW50ZXJjZXB0b3JzMi5lbmNvZGVCdWZmZXIpKHJhd1JlcXVlc3QuYm9keSB8fCBcIlwiKSxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFuZGxlUmVxdWVzdC50c1xudmFyIGltcG9ydF91bnRpbDIgPSByZXF1aXJlKFwiQG9wZW4tZHJhZnQvdW50aWxcIik7XG5cbi8vIHNyYy91dGlscy9nZXRSZXNwb25zZS50c1xudmFyIGdldFJlc3BvbnNlID0gYXN5bmMgKHJlcXVlc3QsIGhhbmRsZXJzLCByZXNvbHV0aW9uQ29udGV4dCkgPT4ge1xuICBjb25zdCByZWxldmFudEhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKChoYW5kbGVyKSA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZXIudGVzdChyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCk7XG4gIH0pO1xuICBpZiAocmVsZXZhbnRIYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFuZGxlcjogdm9pZCAwLFxuICAgICAgcmVzcG9uc2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVsZXZhbnRIYW5kbGVycy5yZWR1Y2UoYXN5bmMgKGV4ZWN1dGlvblJlc3VsdCwgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IGF3YWl0IGV4ZWN1dGlvblJlc3VsdDtcbiAgICBpZiAoISEocHJldmlvdXNSZXN1bHRzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91c1Jlc3VsdHMucmVzcG9uc2UpKSB7XG4gICAgICByZXR1cm4gZXhlY3V0aW9uUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgaGFuZGxlci5ydW4ocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICAgIGlmIChyZXN1bHQyID09PSBudWxsIHx8IHJlc3VsdDIuaGFuZGxlci5zaG91bGRTa2lwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQyLnJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXF1ZXN0OiByZXN1bHQyLnJlcXVlc3QsXG4gICAgICAgIGhhbmRsZXI6IHJlc3VsdDIuaGFuZGxlcixcbiAgICAgICAgcmVzcG9uc2U6IHZvaWQgMCxcbiAgICAgICAgcGFyc2VkUmVzdWx0OiByZXN1bHQyLnBhcnNlZFJlc3VsdFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdDIucmVzcG9uc2Uub25jZSkge1xuICAgICAgaGFuZGxlci5tYXJrQXNTa2lwcGVkKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0MjtcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKG51bGwpKTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFuZGxlcjogdm9pZCAwLFxuICAgICAgcmVzcG9uc2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyOiByZXN1bHQuaGFuZGxlcixcbiAgICBwdWJsaWNSZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICBwYXJzZWRSZXF1ZXN0OiByZXN1bHQucGFyc2VkUmVzdWx0LFxuICAgIHJlc3BvbnNlOiByZXN1bHQucmVzcG9uc2VcbiAgfTtcbn07XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L29uVW5oYW5kbGVkUmVxdWVzdC50c1xudmFyIGltcG9ydF9qc19sZXZlbnNodGVpbiA9IF9fdG9FU00ocmVxdWlyZShcImpzLWxldmVuc2h0ZWluXCIpKTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3BhcnNlR3JhcGhRTFJlcXVlc3QudHNcbnZhciBpbXBvcnRfZ3JhcGhxbCA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9nZXRQdWJsaWNVcmxGcm9tUmVxdWVzdC50c1xudmFyIGdldFB1YmxpY1VybEZyb21SZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgcmV0dXJuIHJlcXVlc3QucmVmZXJyZXIuc3RhcnRzV2l0aChyZXF1ZXN0LnVybC5vcmlnaW4pID8gcmVxdWVzdC51cmwucGF0aG5hbWUgOiBuZXcgVVJMKFxuICAgIHJlcXVlc3QudXJsLnBhdGhuYW1lLFxuICAgIGAke3JlcXVlc3QudXJsLnByb3RvY29sfS8vJHtyZXF1ZXN0LnVybC5ob3N0fWBcbiAgKS5ocmVmO1xufTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3BhcnNlR3JhcGhRTFJlcXVlc3QudHNcbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnROb2RlKG5vZGUpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBvcGVyYXRpb25EZWYgPSBub2RlLmRlZmluaXRpb25zLmZpbmQoKGRlZikgPT4ge1xuICAgIHJldHVybiBkZWYua2luZCA9PT0gXCJPcGVyYXRpb25EZWZpbml0aW9uXCI7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvblR5cGU6IG9wZXJhdGlvbkRlZiA9PSBudWxsID8gdm9pZCAwIDogb3BlcmF0aW9uRGVmLm9wZXJhdGlvbixcbiAgICBvcGVyYXRpb25OYW1lOiAoX2EgPSBvcGVyYXRpb25EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZXJhdGlvbkRlZi5uYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2EudmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUXVlcnkocXVlcnkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhc3QgPSAoMCwgaW1wb3J0X2dyYXBocWwucGFyc2UpKHF1ZXJ5KTtcbiAgICByZXR1cm4gcGFyc2VEb2N1bWVudE5vZGUoYXN0KTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIGVycm9yMjtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdE11bHRpcGFydFZhcmlhYmxlcyh2YXJpYWJsZXMsIG1hcCwgZmlsZXMpIHtcbiAgY29uc3Qgb3BlcmF0aW9ucyA9IHsgdmFyaWFibGVzIH07XG4gIGZvciAoY29uc3QgW2tleSwgcGF0aEFycmF5XSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgaWYgKCEoa2V5IGluIGZpbGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiBmaWxlcyBkbyBub3QgaGF2ZSBhIGtleSAnJHtrZXl9JyAuYCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZG90UGF0aCBvZiBwYXRoQXJyYXkpIHtcbiAgICAgIGNvbnN0IFtsYXN0UGF0aCwgLi4ucmV2ZXJzZWRQYXRoc10gPSBkb3RQYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBwYXRocyA9IHJldmVyc2VkUGF0aHMucmV2ZXJzZSgpO1xuICAgICAgbGV0IHRhcmdldCA9IG9wZXJhdGlvbnM7XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCEocGF0aCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAnJHtwYXRoc30nIGlzIG5vdCBpbiBvcGVyYXRpb25zLmApO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFtwYXRoXTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFtsYXN0UGF0aF0gPSBmaWxlc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3BlcmF0aW9ucy52YXJpYWJsZXM7XG59XG5mdW5jdGlvbiBnZXRHcmFwaFFMSW5wdXQocmVxdWVzdCkge1xuICB2YXIgX2EsIF9iO1xuICBzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBcIkdFVFwiOiB7XG4gICAgICBjb25zdCBxdWVyeSA9IHJlcXVlc3QudXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJxdWVyeVwiKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHJlcXVlc3QudXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2YXJpYWJsZXNcIikgfHwgXCJcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICB2YXJpYWJsZXM6IGpzb25QYXJzZSh2YXJpYWJsZXMpXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiUE9TVFwiOiB7XG4gICAgICBpZiAoKF9hID0gcmVxdWVzdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcnkpIHtcbiAgICAgICAgY29uc3QgeyBxdWVyeSwgdmFyaWFibGVzIH0gPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgdmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoKF9iID0gcmVxdWVzdC5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3BlcmF0aW9ucykge1xuICAgICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIG1hcCwgLi4uZmlsZXMgfSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgY29uc3QgcGFyc2VkT3BlcmF0aW9ucyA9IGpzb25QYXJzZShcbiAgICAgICAgICBvcGVyYXRpb25zXG4gICAgICAgICkgfHwge307XG4gICAgICAgIGlmICghcGFyc2VkT3BlcmF0aW9ucy5xdWVyeSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZE1hcCA9IGpzb25QYXJzZShtYXAgfHwgXCJcIikgfHwge307XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHBhcnNlZE9wZXJhdGlvbnMudmFyaWFibGVzID8gZXh0cmFjdE11bHRpcGFydFZhcmlhYmxlcyhcbiAgICAgICAgICBwYXJzZWRPcGVyYXRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICBwYXJzZWRNYXAsXG4gICAgICAgICAgZmlsZXNcbiAgICAgICAgKSA6IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5OiBwYXJzZWRPcGVyYXRpb25zLnF1ZXJ5LFxuICAgICAgICAgIHZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCkge1xuICBjb25zdCBpbnB1dCA9IGdldEdyYXBoUUxJbnB1dChyZXF1ZXN0KTtcbiAgaWYgKCFpbnB1dCB8fCAhaW5wdXQucXVlcnkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHsgcXVlcnksIHZhcmlhYmxlcyB9ID0gaW5wdXQ7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHBhcnNlUXVlcnkocXVlcnkpO1xuICBpZiAocGFyc2VkUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjb25zdCByZXF1ZXN0UHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgJ0ZhaWxlZCB0byBpbnRlcmNlcHQgYSBHcmFwaFFMIHJlcXVlc3QgdG8gXCIlcyAlc1wiOiBjYW5ub3QgcGFyc2UgcXVlcnkuIFNlZSB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoZSBwYXJzZXIgYmVsb3cuXFxuXFxuJXMnLFxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcmVxdWVzdFB1YmxpY1VybCxcbiAgICAgICAgcGFyc2VkUmVzdWx0Lm1lc3NhZ2VcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uVHlwZTogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvblR5cGUsXG4gICAgb3BlcmF0aW9uTmFtZTogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUsXG4gICAgdmFyaWFibGVzXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL2dldFN0YXR1c0NvZGVDb2xvci50c1xuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUNvbG9yKHN0YXR1czIpIHtcbiAgaWYgKHN0YXR1czIgPCAzMDApIHtcbiAgICByZXR1cm4gXCIjNjlBQjMyXCIgLyogU3VjY2VzcyAqLztcbiAgfVxuICBpZiAoc3RhdHVzMiA8IDQwMCkge1xuICAgIHJldHVybiBcIiNGMEJCNEJcIiAvKiBXYXJuaW5nICovO1xuICB9XG4gIHJldHVybiBcIiNFOTVGNURcIiAvKiBEYW5nZXIgKi87XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL2dldFRpbWVzdGFtcC50c1xuZnVuY3Rpb24gZ2V0VGltZXN0YW1wKCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICByZXR1cm4gW25vdy5nZXRIb3VycygpLCBub3cuZ2V0TWludXRlcygpLCBub3cuZ2V0U2Vjb25kcygpXS5tYXAoU3RyaW5nKS5tYXAoKGNodW5rKSA9PiBjaHVuay5zbGljZSgwLCAyKSkubWFwKChjaHVuaykgPT4gY2h1bmsucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiOlwiKTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvcHJlcGFyZVJlcXVlc3QudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXF1ZXN0LFxuICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMuYWxsKClcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvcHJlcGFyZVJlc3BvbnNlLnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw2ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5mdW5jdGlvbiBwcmVwYXJlUmVzcG9uc2UocmVzKSB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9ICgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDYub2JqZWN0VG9IZWFkZXJzKShyZXMuaGVhZGVycyk7XG4gIGNvbnN0IHBhcnNlZEJvZHkgPSBwYXJzZUJvZHkocmVzLmJvZHksIHJlc3BvbnNlSGVhZGVycyk7XG4gIHJldHVybiB7XG4gICAgLi4ucmVzLFxuICAgIGJvZHk6IHBhcnNlZEJvZHlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL21hdGNoUmVxdWVzdFVybC50c1xudmFyIGltcG9ydF9wYXRoX3RvX3JlZ2V4cCA9IHJlcXVpcmUoXCJwYXRoLXRvLXJlZ2V4cFwiKTtcbnZhciBpbXBvcnRfZ2V0Q2xlYW5VcmwgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvdXRpbHMvZ2V0Q2xlYW5VcmwuanNcIik7XG5cbi8vIHNyYy91dGlscy91cmwvY2xlYW5VcmwudHNcbnZhciBSRURVTkRBTlRfQ0hBUkFDVEVSU19FWFAgPSAvW1xcP3wjXS4qJC9nO1xuZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBVUkwoYC8ke3BhdGh9YCwgXCJodHRwOi8vbG9jYWxob3N0XCIpLnNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShSRURVTkRBTlRfQ0hBUkFDVEVSU19FWFAsIFwiXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvdXJsL2lzQWJzb2x1dGVVcmwudHNcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwodXJsKSB7XG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9nZXRBYnNvbHV0ZVVybC50c1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVVcmwocGF0aCwgYmFzZVVybCkge1xuICBpZiAoaXNBYnNvbHV0ZVVybChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIqXCIpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgY29uc3Qgb3JpZ2luID0gYmFzZVVybCB8fCB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYmFzZVVSSTtcbiAgcmV0dXJuIG9yaWdpbiA/IGRlY29kZVVSSShuZXcgVVJMKGVuY29kZVVSSShwYXRoKSwgb3JpZ2luKS5ocmVmKSA6IHBhdGg7XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9ub3JtYWxpemVQYXRoLnRzXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgsIGJhc2VVcmwpIHtcbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBjb25zdCBtYXliZUFic29sdXRlVXJsID0gZ2V0QWJzb2x1dGVVcmwocGF0aCwgYmFzZVVybCk7XG4gIHJldHVybiBjbGVhblVybChtYXliZUFic29sdXRlVXJsKTtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL21hdGNoUmVxdWVzdFVybC50c1xuZnVuY3Rpb24gY29lcmNlUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoXG4gICAgLyhbOmEtekEtWl8tXSopKFxcKnsxLDJ9KSsvZyxcbiAgICAoXywgcGFyYW1ldGVyTmFtZSwgd2lsZGNhcmQpID0+IHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBcIiguKilcIjtcbiAgICAgIGlmICghcGFyYW1ldGVyTmFtZSkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbWV0ZXJOYW1lLnN0YXJ0c1dpdGgoXCI6XCIpID8gYCR7cGFyYW1ldGVyTmFtZX0ke3dpbGRjYXJkfWAgOiBgJHtwYXJhbWV0ZXJOYW1lfSR7ZXhwcmVzc2lvbn1gO1xuICAgIH1cbiAgKS5yZXBsYWNlKC8oW15cXC9dKSg6KSg/PVxcZCspLywgXCIkMVxcXFwkMlwiKS5yZXBsYWNlKC9eKFteXFwvXSspKDopKD89XFwvXFwvKS8sIFwiJDFcXFxcJDJcIik7XG59XG5mdW5jdGlvbiBtYXRjaFJlcXVlc3RVcmwodXJsLCBwYXRoLCBiYXNlVXJsKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLCBiYXNlVXJsKTtcbiAgY29uc3QgY2xlYW5QYXRoID0gdHlwZW9mIG5vcm1hbGl6ZWRQYXRoID09PSBcInN0cmluZ1wiID8gY29lcmNlUGF0aChub3JtYWxpemVkUGF0aCkgOiBub3JtYWxpemVkUGF0aDtcbiAgY29uc3QgY2xlYW5VcmwyID0gKDAsIGltcG9ydF9nZXRDbGVhblVybC5nZXRDbGVhblVybCkodXJsKTtcbiAgY29uc3QgcmVzdWx0ID0gKDAsIGltcG9ydF9wYXRoX3RvX3JlZ2V4cC5tYXRjaCkoY2xlYW5QYXRoLCB7IGRlY29kZTogZGVjb2RlVVJJQ29tcG9uZW50IH0pKGNsZWFuVXJsMik7XG4gIGNvbnN0IHBhcmFtcyA9IHJlc3VsdCAmJiByZXN1bHQucGFyYW1zIHx8IHt9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IHJlc3VsdCAhPT0gZmFsc2UsXG4gICAgcGFyYW1zXG4gIH07XG59XG5cbi8vIHNyYy9oYW5kbGVycy9SZXF1ZXN0SGFuZGxlci50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsOCA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuXG4vLyBzcmMvcmVzcG9uc2UudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDcgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2NvbXBvc2UudHNcbmZ1bmN0aW9uIGNvbXBvc2UoLi4uZm5zKSB7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBmbnMucmVkdWNlUmlnaHQoKGxlZnRGbiwgcmlnaHRGbikgPT4ge1xuICAgICAgcmV0dXJuIGxlZnRGbiBpbnN0YW5jZW9mIFByb21pc2UgPyBQcm9taXNlLnJlc29sdmUobGVmdEZuKS50aGVuKHJpZ2h0Rm4pIDogcmlnaHRGbihsZWZ0Rm4pO1xuICAgIH0sIGFyZ3NbMF0pO1xuICB9O1xufVxuXG4vLyBzcmMvcmVzcG9uc2UudHNcbnZhciBkZWZhdWx0UmVzcG9uc2UgPSB7XG4gIHN0YXR1czogMjAwLFxuICBzdGF0dXNUZXh0OiBcIk9LXCIsXG4gIGJvZHk6IG51bGwsXG4gIGRlbGF5OiAwLFxuICBvbmNlOiBmYWxzZSxcbiAgcGFzc3Rocm91Z2g6IGZhbHNlXG59O1xudmFyIGRlZmF1bHRSZXNwb25zZVRyYW5zZm9ybWVycyA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbihyZXNwb25zZU92ZXJyaWRlcywgZGVmYXVsdFRyYW5zZm9ybWVycyA9IGRlZmF1bHRSZXNwb25zZVRyYW5zZm9ybWVycykge1xuICByZXR1cm4gYXN5bmMgKC4uLnRyYW5zZm9ybWVycykgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxSZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIGRlZmF1bHRSZXNwb25zZSxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczogbmV3IGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNy5IZWFkZXJzKHtcbiAgICAgICAgICBcIngtcG93ZXJlZC1ieVwiOiBcIm1zd1wiXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VPdmVycmlkZXNcbiAgICApO1xuICAgIGNvbnN0IHJlc29sdmVkVHJhbnNmb3JtZXJzID0gW1xuICAgICAgLi4uZGVmYXVsdFRyYW5zZm9ybWVycyxcbiAgICAgIC4uLnRyYW5zZm9ybWVyc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IHJlc29sdmVkUmVzcG9uc2UgPSByZXNvbHZlZFRyYW5zZm9ybWVycy5sZW5ndGggPiAwID8gY29tcG9zZSguLi5yZXNvbHZlZFRyYW5zZm9ybWVycykoaW5pdGlhbFJlc3BvbnNlKSA6IGluaXRpYWxSZXNwb25zZTtcbiAgICByZXR1cm4gcmVzb2x2ZWRSZXNwb25zZTtcbiAgfTtcbn1cbnZhciByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbigpLCB7XG4gIG9uY2U6IGNyZWF0ZVJlc3BvbnNlQ29tcG9zaXRpb24oeyBvbmNlOiB0cnVlIH0pLFxuICBuZXR3b3JrRXJyb3IobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IobWVzc2FnZSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvZ2V0Q2FsbEZyYW1lLnRzXG52YXIgU09VUkNFX0ZSQU1FID0gL1tcXC9cXFxcXW1zd1tcXC9cXFxcXXNyY1tcXC9cXFxcXSguKykvO1xudmFyIEJVSUxEX0ZSQU1FID0gLyhub2RlX21vZHVsZXMpP1tcXC9cXFxcXWxpYltcXC9cXFxcXSh1bWR8ZXNtfGlpZWZ8Y2pzKVtcXC9cXFxcXXxeW15cXC9cXFxcXSokLztcbmZ1bmN0aW9uIGdldENhbGxGcmFtZShlcnJvcjIpIHtcbiAgY29uc3Qgc3RhY2sgPSBlcnJvcjIuc3RhY2s7XG4gIGlmICghc3RhY2spIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZnJhbWVzID0gc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSk7XG4gIGNvbnN0IGRlY2xhcmF0aW9uRnJhbWUgPSBmcmFtZXMuZmluZCgoZnJhbWUpID0+IHtcbiAgICByZXR1cm4gIShTT1VSQ0VfRlJBTUUudGVzdChmcmFtZSkgfHwgQlVJTERfRlJBTUUudGVzdChmcmFtZSkpO1xuICB9KTtcbiAgaWYgKCFkZWNsYXJhdGlvbkZyYW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRlY2xhcmF0aW9uUGF0aCA9IGRlY2xhcmF0aW9uRnJhbWUucmVwbGFjZSgvXFxzKmF0IFteKCldKlxcKChbXildKylcXCkvLCBcIiQxXCIpLnJlcGxhY2UoL15ALywgXCJcIik7XG4gIHJldHVybiBkZWNsYXJhdGlvblBhdGg7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9pc0l0ZXJhYmxlLnRzXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGZuKSB7XG4gIGlmICghZm4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBmbltTeW1ib2wuaXRlcmF0b3JdID09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2hhbmRsZXJzL1JlcXVlc3RIYW5kbGVyLnRzXG52YXIgZGVmYXVsdENvbnRleHQgPSB7XG4gIHN0YXR1cyxcbiAgc2V0LFxuICBkZWxheSxcbiAgZmV0Y2hcbn07XG52YXIgUmVxdWVzdEhhbmRsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNob3VsZFNraXAgPSBmYWxzZTtcbiAgICB0aGlzLmN0eCA9IG9wdGlvbnMuY3R4IHx8IGRlZmF1bHRDb250ZXh0O1xuICAgIHRoaXMucmVzb2x2ZXIgPSBvcHRpb25zLnJlc29sdmVyO1xuICAgIGNvbnN0IGNhbGxGcmFtZSA9IGdldENhbGxGcmFtZShuZXcgRXJyb3IoKSk7XG4gICAgdGhpcy5pbmZvID0ge1xuICAgICAgLi4ub3B0aW9ucy5pbmZvLFxuICAgICAgY2FsbEZyYW1lXG4gICAgfTtcbiAgfVxuICBwYXJzZShfcmVxdWVzdCwgX3Jlc29sdXRpb25Db250ZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdGVzdChyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0aGlzLnBhcnNlKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgfVxuICBnZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIF9wYXJzZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBtYXJrQXNTa2lwcGVkKHNob3VsZFNraXAgPSB0cnVlKSB7XG4gICAgdGhpcy5zaG91bGRTa2lwID0gc2hvdWxkU2tpcDtcbiAgfVxuICBhc3luYyBydW4ocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5zaG91bGRTa2lwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gdGhpcy5wYXJzZShyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCk7XG4gICAgY29uc3Qgc2hvdWxkSW50ZXJjZXB0ID0gdGhpcy5wcmVkaWNhdGUoXG4gICAgICByZXF1ZXN0LFxuICAgICAgcGFyc2VkUmVzdWx0LFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHRcbiAgICApO1xuICAgIGlmICghc2hvdWxkSW50ZXJjZXB0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcHVibGljUmVxdWVzdCA9IHRoaXMuZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpO1xuICAgIGNvbnN0IGV4ZWN1dGVSZXNvbHZlciA9IHRoaXMud3JhcFJlc29sdmVyKHRoaXMucmVzb2x2ZXIpO1xuICAgIGNvbnN0IG1vY2tlZFJlc3BvbnNlID0gYXdhaXQgZXhlY3V0ZVJlc29sdmVyKFxuICAgICAgcHVibGljUmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdGhpcy5jdHhcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4ZWN1dGlvblJlc3VsdChcbiAgICAgIHBhcnNlZFJlc3VsdCxcbiAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICBtb2NrZWRSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgd3JhcFJlc29sdmVyKHJlc29sdmVyKSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgY3R4KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc29sdmVyR2VuZXJhdG9yIHx8IGF3YWl0IHJlc29sdmVyKHJlcSwgcmVzLCBjdHgpO1xuICAgICAgaWYgKGlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSByZXN1bHRbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICAgICAgY29uc3QgbmV4dFJlc3BvbnNlID0gYXdhaXQgdmFsdWU7XG4gICAgICAgIGlmICghbmV4dFJlc3BvbnNlICYmIGRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlckdlbmVyYXRvclJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZXJHZW5lcmF0b3IpIHtcbiAgICAgICAgICB0aGlzLnJlc29sdmVyR2VuZXJhdG9yID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3JSZXN1bHQgPSBuZXh0UmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBuZXh0UmVzcG9uc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgY3JlYXRlRXhlY3V0aW9uUmVzdWx0KHBhcnNlZFJlc3VsdCwgcmVxdWVzdCwgcmVzcG9uc2UyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXI6IHRoaXMsXG4gICAgICBwYXJzZWRSZXN1bHQ6IHBhcnNlZFJlc3VsdCB8fCBudWxsLFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlOiByZXNwb25zZTIgfHwgbnVsbFxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9oYW5kbGVycy9SZXN0SGFuZGxlci50c1xudmFyIFJFU1RNZXRob2RzID0gLyogQF9fUFVSRV9fICovICgoUkVTVE1ldGhvZHMyKSA9PiB7XG4gIFJFU1RNZXRob2RzMltcIkhFQURcIl0gPSBcIkhFQURcIjtcbiAgUkVTVE1ldGhvZHMyW1wiR0VUXCJdID0gXCJHRVRcIjtcbiAgUkVTVE1ldGhvZHMyW1wiUE9TVFwiXSA9IFwiUE9TVFwiO1xuICBSRVNUTWV0aG9kczJbXCJQVVRcIl0gPSBcIlBVVFwiO1xuICBSRVNUTWV0aG9kczJbXCJQQVRDSFwiXSA9IFwiUEFUQ0hcIjtcbiAgUkVTVE1ldGhvZHMyW1wiT1BUSU9OU1wiXSA9IFwiT1BUSU9OU1wiO1xuICBSRVNUTWV0aG9kczJbXCJERUxFVEVcIl0gPSBcIkRFTEVURVwiO1xuICByZXR1cm4gUkVTVE1ldGhvZHMyO1xufSkoUkVTVE1ldGhvZHMgfHwge30pO1xudmFyIHJlc3RDb250ZXh0ID0ge1xuICAuLi5kZWZhdWx0Q29udGV4dCxcbiAgY29va2llLFxuICBib2R5LFxuICB0ZXh0LFxuICBqc29uLFxuICB4bWxcbn07XG52YXIgUmVzdFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIE1vY2tlZFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0LCBwYXJhbXMpIHtcbiAgICBzdXBlcihyZXF1ZXN0LnVybCwge1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIGJvZHk6IHJlcXVlc3RbXCJfYm9keVwiXVxuICAgIH0pO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuaWQgPSByZXF1ZXN0LmlkO1xuICB9XG59O1xudmFyIFJlc3RIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBSZXF1ZXN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKG1ldGhvZCwgcGF0aCwgcmVzb2x2ZXIpIHtcbiAgICBzdXBlcih7XG4gICAgICBpbmZvOiB7XG4gICAgICAgIGhlYWRlcjogYCR7bWV0aG9kfSAke3BhdGh9YCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWV0aG9kXG4gICAgICB9LFxuICAgICAgY3R4OiByZXN0Q29udGV4dCxcbiAgICAgIHJlc29sdmVyXG4gICAgfSk7XG4gICAgdGhpcy5jaGVja1JlZHVuZGFudFF1ZXJ5UGFyYW1ldGVycygpO1xuICB9XG4gIGNoZWNrUmVkdW5kYW50UXVlcnlQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHsgbWV0aG9kLCBwYXRoIH0gPSB0aGlzLmluZm87XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gY2xlYW5VcmwocGF0aCk7XG4gICAgaWYgKHVybCA9PT0gcGF0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBnZXRTZWFyY2hQYXJhbXMocGF0aCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBbXTtcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgoXywgcGFyYW1OYW1lKSA9PiB7XG4gICAgICBxdWVyeVBhcmFtcy5wdXNoKHBhcmFtTmFtZSk7XG4gICAgfSk7XG4gICAgZGV2VXRpbHMud2FybihcbiAgICAgIGBGb3VuZCBhIHJlZHVuZGFudCB1c2FnZSBvZiBxdWVyeSBwYXJhbWV0ZXJzIGluIHRoZSByZXF1ZXN0IGhhbmRsZXIgVVJMIGZvciBcIiR7bWV0aG9kfSAke3BhdGh9XCIuIFBsZWFzZSBtYXRjaCBhZ2FpbnN0IGEgcGF0aCBpbnN0ZWFkIGFuZCBhY2Nlc3MgcXVlcnkgcGFyYW1ldGVycyBpbiB0aGUgcmVzcG9uc2UgcmVzb2x2ZXIgZnVuY3Rpb24gdXNpbmcgXCJyZXEudXJsLnNlYXJjaFBhcmFtc1wiLmBcbiAgICApO1xuICB9XG4gIHBhcnNlKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgcmV0dXJuIG1hdGNoUmVxdWVzdFVybChcbiAgICAgIHJlcXVlc3QudXJsLFxuICAgICAgdGhpcy5pbmZvLnBhdGgsXG4gICAgICByZXNvbHV0aW9uQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcmVzb2x1dGlvbkNvbnRleHQuYmFzZVVybFxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gbmV3IFJlc3RSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdC5wYXJhbXMgfHwge30pO1xuICB9XG4gIHByZWRpY2F0ZShyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICBjb25zdCBtYXRjaGVzTWV0aG9kID0gdGhpcy5pbmZvLm1ldGhvZCBpbnN0YW5jZW9mIFJlZ0V4cCA/IHRoaXMuaW5mby5tZXRob2QudGVzdChyZXF1ZXN0Lm1ldGhvZCkgOiBpc1N0cmluZ0VxdWFsKHRoaXMuaW5mby5tZXRob2QsIHJlcXVlc3QubWV0aG9kKTtcbiAgICByZXR1cm4gbWF0Y2hlc01ldGhvZCAmJiBwYXJzZWRSZXN1bHQubWF0Y2hlcztcbiAgfVxuICBsb2cocmVxdWVzdCwgcmVzcG9uc2UyKSB7XG4gICAgY29uc3QgcHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgbG9nZ2VkUmVxdWVzdCA9IHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlc3BvbnNlID0gcHJlcGFyZVJlc3BvbnNlKHJlc3BvbnNlMik7XG4gICAgY29uc3Qgc3RhdHVzQ29sb3IgPSBnZXRTdGF0dXNDb2RlQ29sb3IocmVzcG9uc2UyLnN0YXR1cyk7XG4gICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXCIlcyAlcyAlcyAoJWMlcyVjKVwiKSxcbiAgICAgIGdldFRpbWVzdGFtcCgpLFxuICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICBwdWJsaWNVcmwsXG4gICAgICBgY29sb3I6JHtzdGF0dXNDb2xvcn1gLFxuICAgICAgYCR7cmVzcG9uc2UyLnN0YXR1c30gJHtyZXNwb25zZTIuc3RhdHVzVGV4dH1gLFxuICAgICAgXCJjb2xvcjppbmhlcml0XCJcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdFwiLCBsb2dnZWRSZXF1ZXN0KTtcbiAgICBjb25zb2xlLmxvZyhcIkhhbmRsZXI6XCIsIHRoaXMpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVzcG9uc2VcIiwgbG9nZ2VkUmVzcG9uc2UpO1xuICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbnRleHQvZmllbGQudHNcbnZhciBpbXBvcnRfb3V0dmFyaWFudDMgPSByZXF1aXJlKFwib3V0dmFyaWFudFwiKTtcbnZhciBmaWVsZCA9IChmaWVsZE5hbWUsIGZpZWxkVmFsdWUpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICB2YWxpZGF0ZUZpZWxkTmFtZShmaWVsZE5hbWUpO1xuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgW2ZpZWxkTmFtZV06IGZpZWxkVmFsdWUgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZE5hbWUoZmllbGROYW1lKSB7XG4gICgwLCBpbXBvcnRfb3V0dmFyaWFudDMuaW52YXJpYW50KShcbiAgICBmaWVsZE5hbWUudHJpbSgpICE9PSBcIlwiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBcIkZhaWxlZCB0byBzZXQgYSBjdXN0b20gZmllbGQgb24gYSBHcmFwaFFMIHJlc3BvbnNlOiBmaWVsZCBuYW1lIGNhbm5vdCBiZSBlbXB0eS5cIlxuICAgIClcbiAgKTtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50My5pbnZhcmlhbnQpKFxuICAgIGZpZWxkTmFtZSAhPT0gXCJkYXRhXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZGF0YSgpXCIgaW5zdGVhZD8nLFxuICAgICAgZmllbGROYW1lXG4gICAgKVxuICApO1xuICAoMCwgaW1wb3J0X291dHZhcmlhbnQzLmludmFyaWFudCkoXG4gICAgZmllbGROYW1lICE9PSBcImVycm9yc1wiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmVycm9ycygpXCIgaW5zdGVhZD8nLFxuICAgICAgZmllbGROYW1lXG4gICAgKVxuICApO1xuICAoMCwgaW1wb3J0X291dHZhcmlhbnQzLmludmFyaWFudCkoXG4gICAgZmllbGROYW1lICE9PSBcImV4dGVuc2lvbnNcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5leHRlbnNpb25zKClcIiBpbnN0ZWFkPycsXG4gICAgICBmaWVsZE5hbWVcbiAgICApXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC90cnlDYXRjaC50c1xuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9uRXhjZXB0aW9uKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICBvbkV4Y2VwdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25FeGNlcHRpb24oZXJyb3IyKTtcbiAgfVxufVxuXG4vLyBzcmMvaGFuZGxlcnMvR3JhcGhRTEhhbmRsZXIudHNcbnZhciBncmFwaHFsQ29udGV4dCA9IHtcbiAgLi4uZGVmYXVsdENvbnRleHQsXG4gIGRhdGEsXG4gIGV4dGVuc2lvbnMsXG4gIGVycm9ycyxcbiAgY29va2llLFxuICBmaWVsZFxufTtcbmZ1bmN0aW9uIGlzRG9jdW1lbnROb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJraW5kXCIgaW4gdmFsdWUgJiYgXCJkZWZpbml0aW9uc1wiIGluIHZhbHVlO1xufVxudmFyIEdyYXBoUUxSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBNb2NrZWRSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgdmFyaWFibGVzLCBvcGVyYXRpb25OYW1lKSB7XG4gICAgc3VwZXIocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiByZXF1ZXN0W1wiX2JvZHlcIl1cbiAgICB9KTtcbiAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICB0aGlzLm9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lO1xuICB9XG59O1xudmFyIEdyYXBoUUxIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBSZXF1ZXN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvblR5cGUsIG9wZXJhdGlvbk5hbWUsIGVuZHBvaW50LCByZXNvbHZlcikge1xuICAgIGxldCByZXNvbHZlZE9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lO1xuICAgIGlmIChpc0RvY3VtZW50Tm9kZShvcGVyYXRpb25OYW1lKSkge1xuICAgICAgY29uc3QgcGFyc2VkTm9kZSA9IHBhcnNlRG9jdW1lbnROb2RlKG9wZXJhdGlvbk5hbWUpO1xuICAgICAgaWYgKHBhcnNlZE5vZGUub3BlcmF0aW9uVHlwZSAhPT0gb3BlcmF0aW9uVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgYSBHcmFwaFFMIGhhbmRsZXI6IHByb3ZpZGVkIGEgRG9jdW1lbnROb2RlIHdpdGggYSBtaXNtYXRjaGVkIG9wZXJhdGlvbiB0eXBlIChleHBlY3RlZCBcIiR7b3BlcmF0aW9uVHlwZX1cIiwgYnV0IGdvdCBcIiR7cGFyc2VkTm9kZS5vcGVyYXRpb25UeXBlfVwiKS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlZE5vZGUub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgYSBHcmFwaFFMIGhhbmRsZXI6IHByb3ZpZGVkIGEgRG9jdW1lbnROb2RlIHdpdGggbm8gb3BlcmF0aW9uIG5hbWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRPcGVyYXRpb25OYW1lID0gcGFyc2VkTm9kZS5vcGVyYXRpb25OYW1lO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBvcGVyYXRpb25UeXBlID09PSBcImFsbFwiID8gYCR7b3BlcmF0aW9uVHlwZX0gKG9yaWdpbjogJHtlbmRwb2ludC50b1N0cmluZygpfSlgIDogYCR7b3BlcmF0aW9uVHlwZX0gJHtyZXNvbHZlZE9wZXJhdGlvbk5hbWV9IChvcmlnaW46ICR7ZW5kcG9pbnQudG9TdHJpbmcoKX0pYDtcbiAgICBzdXBlcih7XG4gICAgICBpbmZvOiB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgb3BlcmF0aW9uVHlwZSxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogcmVzb2x2ZWRPcGVyYXRpb25OYW1lXG4gICAgICB9LFxuICAgICAgY3R4OiBncmFwaHFsQ29udGV4dCxcbiAgICAgIHJlc29sdmVyXG4gICAgfSk7XG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICB9XG4gIHBhcnNlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdHJ5Q2F0Y2goXG4gICAgICAoKSA9PiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpLFxuICAgICAgKGVycm9yMikgPT4gY29uc29sZS5lcnJvcihlcnJvcjIubWVzc2FnZSlcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gbmV3IEdyYXBoUUxSZXF1ZXN0KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIChfYSA9IHBhcnNlZFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVzdWx0LnZhcmlhYmxlcykgIT0gbnVsbCA/IF9hIDoge30sXG4gICAgICAoX2IgPSBwYXJzZWRSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lKSAhPSBudWxsID8gX2IgOiBcIlwiXG4gICAgKTtcbiAgfVxuICBwcmVkaWNhdGUocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgaWYgKCFwYXJzZWRSZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSAmJiB0aGlzLmluZm8ub3BlcmF0aW9uVHlwZSAhPT0gXCJhbGxcIikge1xuICAgICAgY29uc3QgcHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICBkZXZVdGlscy53YXJuKGBGYWlsZWQgdG8gaW50ZXJjZXB0IGEgR3JhcGhRTCByZXF1ZXN0IGF0IFwiJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9XCI6IGFub255bW91cyBHcmFwaFFMIG9wZXJhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5cbkNvbnNpZGVyIG5hbWluZyB0aGlzIG9wZXJhdGlvbiBvciB1c2luZyBcImdyYXBocWwub3BlcmF0aW9uKClcIiByZXF1ZXN0IGhhbmRsZXIgdG8gaW50ZXJjZXB0IEdyYXBoUUwgcmVxdWVzdHMgcmVnYXJkbGVzcyBvZiB0aGVpciBvcGVyYXRpb24gbmFtZS90eXBlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9hcGkvZ3JhcGhxbC9vcGVyYXRpb24gICAgICBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdVcmwgPSBtYXRjaFJlcXVlc3RVcmwocmVxdWVzdC51cmwsIHRoaXMuZW5kcG9pbnQpO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nT3BlcmF0aW9uVHlwZSA9IHRoaXMuaW5mby5vcGVyYXRpb25UeXBlID09PSBcImFsbFwiIHx8IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25UeXBlID09PSB0aGlzLmluZm8ub3BlcmF0aW9uVHlwZTtcbiAgICBjb25zdCBoYXNNYXRjaGluZ09wZXJhdGlvbk5hbWUgPSB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCA/IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lLnRlc3QocGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUgfHwgXCJcIikgOiBwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSA9PT0gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWU7XG4gICAgcmV0dXJuIGhhc01hdGNoaW5nVXJsLm1hdGNoZXMgJiYgaGFzTWF0Y2hpbmdPcGVyYXRpb25UeXBlICYmIGhhc01hdGNoaW5nT3BlcmF0aW9uTmFtZTtcbiAgfVxuICBsb2cocmVxdWVzdCwgcmVzcG9uc2UyLCBwYXJzZWRSZXF1ZXN0KSB7XG4gICAgY29uc3QgbG9nZ2VkUmVxdWVzdCA9IHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlc3BvbnNlID0gcHJlcGFyZVJlc3BvbnNlKHJlc3BvbnNlMik7XG4gICAgY29uc3Qgc3RhdHVzQ29sb3IgPSBnZXRTdGF0dXNDb2RlQ29sb3IocmVzcG9uc2UyLnN0YXR1cyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSAocGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25OYW1lKSA/IGAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uVHlwZX0gJHtwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvbk5hbWV9YCA6IGBhbm9ueW1vdXMgJHtwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvblR5cGV9YDtcbiAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcIiVzICVzICglYyVzJWMpXCIpLFxuICAgICAgZ2V0VGltZXN0YW1wKCksXG4gICAgICBgJHtyZXF1ZXN0SW5mb31gLFxuICAgICAgYGNvbG9yOiR7c3RhdHVzQ29sb3J9YCxcbiAgICAgIGAke3Jlc3BvbnNlMi5zdGF0dXN9ICR7cmVzcG9uc2UyLnN0YXR1c1RleHR9YCxcbiAgICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3Q6XCIsIGxvZ2dlZFJlcXVlc3QpO1xuICAgIGNvbnNvbGUubG9nKFwiSGFuZGxlcjpcIiwgdGhpcyk7XG4gICAgY29uc29sZS5sb2coXCJSZXNwb25zZTpcIiwgbG9nZ2VkUmVzcG9uc2UpO1xuICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3Qvb25VbmhhbmRsZWRSZXF1ZXN0LnRzXG52YXIgTUFYX01BVENIX1NDT1JFID0gMztcbnZhciBNQVhfU1VHR0VTVElPTl9DT1VOVCA9IDQ7XG52YXIgVFlQRV9NQVRDSF9ERUxUQSA9IDAuNTtcbmZ1bmN0aW9uIGdyb3VwSGFuZGxlcnNCeVR5cGUoaGFuZGxlcnMpIHtcbiAgcmV0dXJuIGhhbmRsZXJzLnJlZHVjZShcbiAgICAoZ3JvdXBzLCBoYW5kbGVyKSA9PiB7XG4gICAgICBpZiAoaGFuZGxlciBpbnN0YW5jZW9mIFJlc3RIYW5kbGVyKSB7XG4gICAgICAgIGdyb3Vwcy5yZXN0LnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoaGFuZGxlciBpbnN0YW5jZW9mIEdyYXBoUUxIYW5kbGVyKSB7XG4gICAgICAgIGdyb3Vwcy5ncmFwaHFsLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sXG4gICAge1xuICAgICAgcmVzdDogW10sXG4gICAgICBncmFwaHFsOiBbXVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlc3RIYW5kbGVyU2NvcmUoKSB7XG4gIHJldHVybiAocmVxdWVzdCwgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHsgcGF0aCwgbWV0aG9kIH0gPSBoYW5kbGVyLmluZm87XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHAgfHwgbWV0aG9kIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGNvbnN0IGhhc1NhbWVNZXRob2QgPSBpc1N0cmluZ0VxdWFsKHJlcXVlc3QubWV0aG9kLCBtZXRob2QpO1xuICAgIGNvbnN0IG1ldGhvZFNjb3JlRGVsdGEgPSBoYXNTYW1lTWV0aG9kID8gVFlQRV9NQVRDSF9ERUxUQSA6IDA7XG4gICAgY29uc3QgcmVxdWVzdFB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IHNjb3JlID0gKDAsIGltcG9ydF9qc19sZXZlbnNodGVpbi5kZWZhdWx0KShyZXF1ZXN0UHVibGljVXJsLCBwYXRoKTtcbiAgICByZXR1cm4gc2NvcmUgLSBtZXRob2RTY29yZURlbHRhO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0R3JhcGhRTEhhbmRsZXJTY29yZShwYXJzZWRRdWVyeSkge1xuICByZXR1cm4gKF8sIGhhbmRsZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcnNlZFF1ZXJ5Lm9wZXJhdGlvbk5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgeyBvcGVyYXRpb25UeXBlLCBvcGVyYXRpb25OYW1lIH0gPSBoYW5kbGVyLmluZm87XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb25OYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGNvbnN0IGhhc1NhbWVPcGVyYXRpb25UeXBlID0gcGFyc2VkUXVlcnkub3BlcmF0aW9uVHlwZSA9PT0gb3BlcmF0aW9uVHlwZTtcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlU2NvcmVEZWx0YSA9IGhhc1NhbWVPcGVyYXRpb25UeXBlID8gVFlQRV9NQVRDSF9ERUxUQSA6IDA7XG4gICAgY29uc3Qgc2NvcmUgPSAoMCwgaW1wb3J0X2pzX2xldmVuc2h0ZWluLmRlZmF1bHQpKHBhcnNlZFF1ZXJ5Lm9wZXJhdGlvbk5hbWUsIG9wZXJhdGlvbk5hbWUpO1xuICAgIHJldHVybiBzY29yZSAtIG9wZXJhdGlvblR5cGVTY29yZURlbHRhO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkSGFuZGxlcihyZXF1ZXN0LCBoYW5kbGVycywgZ2V0U2NvcmUpIHtcbiAgY29uc3Qgc3VnZ2VzdGVkSGFuZGxlcnMgPSBoYW5kbGVycy5yZWR1Y2UoKHN1Z2dlc3Rpb25zLCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3Qgc2NvcmUgPSBnZXRTY29yZShyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICByZXR1cm4gc3VnZ2VzdGlvbnMuY29uY2F0KFtbc2NvcmUsIGhhbmRsZXJdXSk7XG4gIH0sIFtdKS5zb3J0KChbbGVmdFNjb3JlXSwgW3JpZ2h0U2NvcmVdKSA9PiBsZWZ0U2NvcmUgLSByaWdodFNjb3JlKS5maWx0ZXIoKFtzY29yZV0pID0+IHNjb3JlIDw9IE1BWF9NQVRDSF9TQ09SRSkuc2xpY2UoMCwgTUFYX1NVR0dFU1RJT05fQ09VTlQpLm1hcCgoWywgaGFuZGxlcl0pID0+IGhhbmRsZXIpO1xuICByZXR1cm4gc3VnZ2VzdGVkSGFuZGxlcnM7XG59XG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRIYW5kbGVyc01lc3NhZ2UoaGFuZGxlcnMpIHtcbiAgaWYgKGhhbmRsZXJzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gYERpZCB5b3UgbWVhbiB0byByZXF1ZXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlc291cmNlcyBpbnN0ZWFkP1xuXG4ke2hhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gYCAgXFx1MjAyMiAke2hhbmRsZXIuaW5mby5oZWFkZXJ9YCkuam9pbihcIlxcblwiKX1gO1xuICB9XG4gIHJldHVybiBgRGlkIHlvdSBtZWFuIHRvIHJlcXVlc3QgXCIke2hhbmRsZXJzWzBdLmluZm8uaGVhZGVyfVwiIGluc3RlYWQ/YDtcbn1cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVxdWVzdChyZXF1ZXN0LCBoYW5kbGVycywgc3RyYXRlZ3kgPSBcIndhcm5cIikge1xuICBjb25zdCBwYXJzZWRHcmFwaFFMUXVlcnkgPSB0cnlDYXRjaCgoKSA9PiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpKTtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVIYW5kbGVyU3VnZ2VzdGlvbigpIHtcbiAgICBjb25zdCBoYW5kbGVyR3JvdXBzID0gZ3JvdXBIYW5kbGVyc0J5VHlwZShoYW5kbGVycyk7XG4gICAgY29uc3QgcmVsZXZhbnRIYW5kbGVycyA9IHBhcnNlZEdyYXBoUUxRdWVyeSA/IGhhbmRsZXJHcm91cHMuZ3JhcGhxbCA6IGhhbmRsZXJHcm91cHMucmVzdDtcbiAgICBjb25zdCBzdWdnZXN0ZWRIYW5kbGVycyA9IGdldFN1Z2dlc3RlZEhhbmRsZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVsZXZhbnRIYW5kbGVycyxcbiAgICAgIHBhcnNlZEdyYXBoUUxRdWVyeSA/IGdldEdyYXBoUUxIYW5kbGVyU2NvcmUocGFyc2VkR3JhcGhRTFF1ZXJ5KSA6IGdldFJlc3RIYW5kbGVyU2NvcmUoKVxuICAgICk7XG4gICAgcmV0dXJuIHN1Z2dlc3RlZEhhbmRsZXJzLmxlbmd0aCA+IDAgPyBnZXRTdWdnZXN0ZWRIYW5kbGVyc01lc3NhZ2Uoc3VnZ2VzdGVkSGFuZGxlcnMpIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVVuaGFuZGxlZFJlcXVlc3RNZXNzYWdlKCkge1xuICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXIgPSBwYXJzZWRHcmFwaFFMUXVlcnkgPyBgJHtwYXJzZWRHcmFwaFFMUXVlcnkub3BlcmF0aW9uVHlwZX0gJHtwYXJzZWRHcmFwaFFMUXVlcnkub3BlcmF0aW9uTmFtZX0gKCR7cmVxdWVzdC5tZXRob2R9ICR7cHVibGljVXJsfSlgIDogYCR7cmVxdWVzdC5tZXRob2R9ICR7cHVibGljVXJsfWA7XG4gICAgY29uc3QgaGFuZGxlclN1Z2dlc3Rpb24gPSBnZW5lcmF0ZUhhbmRsZXJTdWdnZXN0aW9uKCk7XG4gICAgY29uc3QgbWVzc2FnZVRlbXBsYXRlID0gW1xuICAgICAgYGNhcHR1cmVkIGEgcmVxdWVzdCB3aXRob3V0IGEgbWF0Y2hpbmcgcmVxdWVzdCBoYW5kbGVyOmAsXG4gICAgICBgICBcXHUyMDIyICR7cmVxdWVzdEhlYWRlcn1gLFxuICAgICAgaGFuZGxlclN1Z2dlc3Rpb24sXG4gICAgICBgSWYgeW91IHN0aWxsIHdpc2ggdG8gaW50ZXJjZXB0IHRoaXMgdW5oYW5kbGVkIHJlcXVlc3QsIHBsZWFzZSBjcmVhdGUgYSByZXF1ZXN0IGhhbmRsZXIgZm9yIGl0LlxuUmVhZCBtb3JlOiBodHRwczovL21zd2pzLmlvL2RvY3MvZ2V0dGluZy1zdGFydGVkL21vY2tzYFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIHJldHVybiBtZXNzYWdlVGVtcGxhdGUuam9pbihcIlxcblxcblwiKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVN0cmF0ZWd5KHN0cmF0ZWd5Mikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW5lcmF0ZVVuaGFuZGxlZFJlcXVlc3RNZXNzYWdlKCk7XG4gICAgc3dpdGNoIChzdHJhdGVneTIpIHtcbiAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgIGRldlV0aWxzLmVycm9yKFwiRXJyb3I6ICVzXCIsIG1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAgICdDYW5ub3QgYnlwYXNzIGEgcmVxdWVzdCB3aGVuIHVzaW5nIHRoZSBcImVycm9yXCIgc3RyYXRlZ3kgZm9yIHRoZSBcIm9uVW5oYW5kbGVkUmVxdWVzdFwiIG9wdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhcm5cIjoge1xuICAgICAgICBkZXZVdGlscy53YXJuKFwiV2FybmluZzogJXNcIiwgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJ5cGFzc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byByZWFjdCB0byBhbiB1bmhhbmRsZWQgcmVxdWVzdDogdW5rbm93biBzdHJhdGVneSBcIiVzXCIuIFBsZWFzZSBwcm92aWRlIG9uZSBvZiB0aGUgc3VwcG9ydGVkIHN0cmF0ZWdpZXMgKFwiYnlwYXNzXCIsIFwid2FyblwiLCBcImVycm9yXCIpIG9yIGEgY3VzdG9tIGNhbGxiYWNrIGZ1bmN0aW9uIGFzIHRoZSB2YWx1ZSBvZiB0aGUgXCJvblVuaGFuZGxlZFJlcXVlc3RcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHN0cmF0ZWd5MlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc3RyYXRlZ3kocmVxdWVzdCwge1xuICAgICAgd2FybmluZzogYXBwbHlTdHJhdGVneS5iaW5kKG51bGwsIFwid2FyblwiKSxcbiAgICAgIGVycm9yOiBhcHBseVN0cmF0ZWd5LmJpbmQobnVsbCwgXCJlcnJvclwiKVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBhcHBseVN0cmF0ZWd5KHN0cmF0ZWd5KTtcbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcmVhZFJlc3BvbnNlQ29va2llcy50c1xudmFyIGltcG9ydF9jb29raWVzMiA9IHJlcXVpcmUoXCJAbXN3anMvY29va2llc1wiKTtcbmZ1bmN0aW9uIHJlYWRSZXNwb25zZUNvb2tpZXMocmVxdWVzdCwgcmVzcG9uc2UyKSB7XG4gIGltcG9ydF9jb29raWVzMi5zdG9yZS5hZGQoeyAuLi5yZXF1ZXN0LCB1cmw6IHJlcXVlc3QudXJsLnRvU3RyaW5nKCkgfSwgcmVzcG9uc2UyKTtcbiAgaW1wb3J0X2Nvb2tpZXMyLnN0b3JlLnBlcnNpc3QoKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhbmRsZVJlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdCwgaGFuZGxlcnMsIG9wdGlvbnMsIGVtaXR0ZXIsIGhhbmRsZVJlcXVlc3RPcHRpb25zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OnN0YXJ0XCIsIHJlcXVlc3QpO1xuICBpZiAocmVxdWVzdC5oZWFkZXJzLmdldChcIngtbXN3LWJ5cGFzc1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2EgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFtsb29rdXBFcnJvciwgbG9va3VwUmVzdWx0XSA9IGF3YWl0ICgwLCBpbXBvcnRfdW50aWwyLnVudGlsKSgoKSA9PiB7XG4gICAgcmV0dXJuIGdldFJlc3BvbnNlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGhhbmRsZXJzLFxuICAgICAgaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLnJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgfSk7XG4gIGlmIChsb29rdXBFcnJvcikge1xuICAgIGVtaXR0ZXIuZW1pdChcInVuaGFuZGxlZEV4Y2VwdGlvblwiLCBsb29rdXBFcnJvciwgcmVxdWVzdCk7XG4gICAgdGhyb3cgbG9va3VwRXJyb3I7XG4gIH1cbiAgY29uc3QgeyBoYW5kbGVyLCByZXNwb25zZTogcmVzcG9uc2UyIH0gPSBsb29rdXBSZXN1bHQ7XG4gIGlmICghaGFuZGxlcikge1xuICAgIG9uVW5oYW5kbGVkUmVxdWVzdChyZXF1ZXN0LCBoYW5kbGVycywgb3B0aW9ucy5vblVuaGFuZGxlZFJlcXVlc3QpO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6dW5oYW5kbGVkXCIsIHJlcXVlc3QpO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfYiA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFyZXNwb25zZTIpIHtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYEV4cGVjdGVkIHJlc3BvbnNlIHJlc29sdmVyIHRvIHJldHVybiBhIG1vY2tlZCByZXNwb25zZSBPYmplY3QsIGJ1dCBnb3QgJXMuIFRoZSBvcmlnaW5hbCByZXNwb25zZSBpcyBnb2luZyB0byBiZSB1c2VkIGluc3RlYWQuXG5cbiAgXFx1MjAyMiAlc1xuICAgICVzYCxcbiAgICAgIHJlc3BvbnNlMixcbiAgICAgIGhhbmRsZXIuaW5mby5oZWFkZXIsXG4gICAgICBoYW5kbGVyLmluZm8uY2FsbEZyYW1lXG4gICAgKTtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2MgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZXNwb25zZTIucGFzc3Rocm91Z2gpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2QgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlYWRSZXNwb25zZUNvb2tpZXMocmVxdWVzdCwgcmVzcG9uc2UyKTtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDptYXRjaFwiLCByZXF1ZXN0KTtcbiAgY29uc3QgcmVxdWlyZWRMb29rdXBSZXN1bHQgPSBsb29rdXBSZXN1bHQ7XG4gIGNvbnN0IHRyYW5zZm9ybWVkUmVzcG9uc2UgPSAoKF9lID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLnRyYW5zZm9ybVJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UyKSkgfHwgcmVzcG9uc2UyO1xuICAoX2YgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25Nb2NrZWRSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhbGwoXG4gICAgaGFuZGxlUmVxdWVzdE9wdGlvbnMsXG4gICAgdHJhbnNmb3JtZWRSZXNwb25zZSxcbiAgICByZXF1aXJlZExvb2t1cFJlc3VsdFxuICApO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkUmVzcG9uc2U7XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL3NlcmlhbGl6ZVJlc3BvbnNlLnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw5ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5hc3luYyBmdW5jdGlvbiBzZXJpYWxpemVSZXNwb25zZShyZXNwb25zZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IHJlc3BvbnNlMi5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzcG9uc2UyLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsOS5mbGF0dGVuSGVhZGVyc09iamVjdCkoKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsOS5oZWFkZXJzVG9PYmplY3QpKHJlc3BvbnNlMi5oZWFkZXJzKSksXG4gICAgYm9keTogYXdhaXQgcmVzcG9uc2UyLmNsb25lKCkudGV4dCgpXG4gIH07XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVSZXF1ZXN0TGlzdGVuZXIudHNcbnZhciBjcmVhdGVSZXF1ZXN0TGlzdGVuZXIgPSAoY29udGV4dCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gYXN5bmMgKGV2ZW50LCBtZXNzYWdlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG1lc3NhZ2VDaGFubmVsID0gbmV3IFdvcmtlckNoYW5uZWwoZXZlbnQucG9ydHNbMF0pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBwYXJzZVdvcmtlclJlcXVlc3QobWVzc2FnZS5wYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaGFuZGxlUmVxdWVzdChcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY29udGV4dC5yZXF1ZXN0SGFuZGxlcnMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNvbnRleHQuZW1pdHRlcixcbiAgICAgICAge1xuICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgICAgIG9uUGFzc3Rocm91Z2hSZXNwb25zZSgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvc3RNZXNzYWdlKFwiTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgb25Nb2NrZWRSZXNwb25zZShyZXNwb25zZTIsIHsgaGFuZGxlciwgcHVibGljUmVxdWVzdCwgcGFyc2VkUmVxdWVzdCB9KSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UyLmJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gY29uc3RydWN0IGEgbW9ja2VkIHJlc3BvbnNlIHdpdGggYSBcIlJlYWRhYmxlU3RyZWFtXCIgYm9keTogbW9ja2VkIHN0cmVhbXMgYXJlIG5vdCBzdXBwb3J0ZWQuIEZvbGxvdyBodHRwczovL2dpdGh1Yi5jb20vbXN3anMvbXN3L2lzc3Vlcy8xMzM2IGZvciBtb3JlIGRldGFpbHMuJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSW5zdGFuY2UgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2UyLmJvZHksIHJlc3BvbnNlMik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUZvckxvZ3MgPSByZXNwb25zZUluc3RhbmNlLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHlCdWZmZXIgPSBhd2FpdCByZXNwb25zZUluc3RhbmNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSByZXNwb25zZTIuYm9keSA9PSBudWxsID8gbnVsbCA6IHJlc3BvbnNlQm9keUJ1ZmZlcjtcbiAgICAgICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICBcIk1PQ0tfUkVTUE9OU0VcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlMixcbiAgICAgICAgICAgICAgICBib2R5OiByZXNwb25zZUJvZHlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW3Jlc3BvbnNlQm9keUJ1ZmZlcl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucXVpZXQpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uY2UoXCJyZXNwb25zZTptb2NrZWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIubG9nKFxuICAgICAgICAgICAgICAgICAgcHVibGljUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHNlcmlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlRm9yTG9ncyksXG4gICAgICAgICAgICAgICAgICBwYXJzZWRSZXF1ZXN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvcikge1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgIG5hbWU6IGVycm9yMi5uYW1lLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yMi5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZGV2VXRpbHMuZXJyb3IoXG4gICAgICAgICAgYFVuY2F1Z2h0IGV4Y2VwdGlvbiBpbiB0aGUgcmVxdWVzdCBoYW5kbGVyIGZvciBcIiVzICVzXCI6XG5cbiVzXG5cblRoaXMgZXhjZXB0aW9uIGhhcyBiZWVuIGdyYWNlZnVsbHkgaGFuZGxlZCBhcyBhIDUwMCByZXNwb25zZSwgaG93ZXZlciwgaXQncyBzdHJvbmdseSByZWNvbW1lbmRlZCB0byByZXNvbHZlIHRoaXMgZXJyb3IsIGFzIGl0IGluZGljYXRlcyBhIG1pc3Rha2UgaW4geW91ciBjb2RlLiBJZiB5b3Ugd2lzaCB0byBtb2NrIGFuIGVycm9yIHJlc3BvbnNlLCBwbGVhc2Ugc2VlIHRoaXMgZ3VpZGU6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9yZWNpcGVzL21vY2tpbmctZXJyb3ItcmVzcG9uc2VzYCxcbiAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICByZXF1ZXN0LnVybCxcbiAgICAgICAgICAoX2EgPSBlcnJvcjIuc3RhY2spICE9IG51bGwgPyBfYSA6IGVycm9yMlxuICAgICAgICApO1xuICAgICAgICBtZXNzYWdlQ2hhbm5lbC5wb3N0TWVzc2FnZShcIk1PQ0tfUkVTUE9OU0VcIiwge1xuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IFwiUmVxdWVzdCBIYW5kbGVyIEVycm9yXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yMi5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IyLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3IyLnN0YWNrXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlMikge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogcmVzcG9uc2UyLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiByZXNwb25zZTIuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiByZXNwb25zZTIuaGVhZGVycy5hbGwoKSxcbiAgICBib2R5OiByZXNwb25zZTIuYm9keSxcbiAgICBkZWxheTogcmVzcG9uc2UyLmRlbGF5XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9yZXF1ZXN0SW50ZWdyaXR5Q2hlY2sudHNcbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RJbnRlZ3JpdHlDaGVjayhjb250ZXh0LCBzZXJ2aWNlV29ya2VyKSB7XG4gIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiSU5URUdSSVRZX0NIRUNLX1JFUVVFU1RcIik7XG4gIGNvbnN0IHsgcGF5bG9hZDogYWN0dWFsQ2hlY2tzdW0gfSA9IGF3YWl0IGNvbnRleHQuZXZlbnRzLm9uY2UoXG4gICAgXCJJTlRFR1JJVFlfQ0hFQ0tfUkVTUE9OU0VcIlxuICApO1xuICBpZiAoYWN0dWFsQ2hlY2tzdW0gIT09IFwiM2Q2YjlmMDY0MTBkMTc5YTdmNzQwNGQ0YmY0YzNjNzBcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDdXJyZW50bHkgYWN0aXZlIFNlcnZpY2UgV29ya2VyICgke2FjdHVhbENoZWNrc3VtfSkgaXMgYmVoaW5kIHRoZSBsYXRlc3QgcHVibGlzaGVkIG9uZSAoJHtcIjNkNmI5ZjA2NDEwZDE3OWE3Zjc0MDRkNGJmNGMzYzcwXCJ9KS5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc2VydmljZVdvcmtlcjtcbn1cblxuLy8gc3JjL3V0aWxzL2RlZmVyTmV0d29ya1JlcXVlc3RzVW50aWwudHNcbnZhciBpbXBvcnRfdW50aWwzID0gcmVxdWlyZShcIkBvcGVuLWRyYWZ0L3VudGlsXCIpO1xuZnVuY3Rpb24gZGVmZXJOZXR3b3JrUmVxdWVzdHNVbnRpbChwcmVkaWNhdGVQcm9taXNlKSB7XG4gIGNvbnN0IG9yaWdpbmFsWGhyU2VuZCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZDtcbiAgd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICgwLCBpbXBvcnRfdW50aWwzLnVudGlsKSgoKSA9PiBwcmVkaWNhdGVQcm9taXNlKS50aGVuKCgpID0+IHtcbiAgICAgIHdpbmRvdy5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IG9yaWdpbmFsWGhyU2VuZDtcbiAgICAgIHRoaXMuc2VuZCguLi5hcmdzKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgb3JpZ2luYWxGZXRjaCA9IHdpbmRvdy5mZXRjaDtcbiAgd2luZG93LmZldGNoID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICBhd2FpdCAoMCwgaW1wb3J0X3VudGlsMy51bnRpbCkoKCkgPT4gcHJlZGljYXRlUHJvbWlzZSk7XG4gICAgd2luZG93LmZldGNoID0gb3JpZ2luYWxGZXRjaDtcbiAgICByZXR1cm4gd2luZG93LmZldGNoKC4uLmFyZ3MpO1xuICB9O1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlUmVzcG9uc2VMaXN0ZW5lci50c1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VMaXN0ZW5lcihjb250ZXh0KSB7XG4gIHJldHVybiAoXywgbWVzc2FnZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHBheWxvYWQ6IHJlc3BvbnNlSnNvbiB9ID0gbWVzc2FnZTtcbiAgICBpZiAoKF9hID0gcmVzcG9uc2VKc29uLnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcIm9wYXF1ZVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZTIgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2VKc29uLmJvZHkgfHwgbnVsbCwgcmVzcG9uc2VKc29uKTtcbiAgICBjb25zdCBpc01vY2tlZFJlc3BvbnNlID0gcmVzcG9uc2UyLmhlYWRlcnMuZ2V0KFwieC1wb3dlcmVkLWJ5XCIpID09PSBcIm1zd1wiO1xuICAgIGlmIChpc01vY2tlZFJlc3BvbnNlKSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOm1vY2tlZFwiLCByZXNwb25zZTIsIHJlc3BvbnNlSnNvbi5yZXF1ZXN0SWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOmJ5cGFzc1wiLCByZXNwb25zZTIsIHJlc3BvbnNlSnNvbi5yZXF1ZXN0SWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL3ZhbGlkYXRlV29ya2VyU2NvcGUudHNcbmZ1bmN0aW9uIHZhbGlkYXRlV29ya2VyU2NvcGUocmVnaXN0cmF0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVpZXQpICYmICFsb2NhdGlvbi5ocmVmLnN0YXJ0c1dpdGgocmVnaXN0cmF0aW9uLnNjb3BlKSkge1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgQ2Fubm90IGludGVyY2VwdCByZXF1ZXN0cyBvbiB0aGlzIHBhZ2UgYmVjYXVzZSBpdCdzIG91dHNpZGUgb2YgdGhlIHdvcmtlcidzIHNjb3BlIChcIiR7cmVnaXN0cmF0aW9uLnNjb3BlfVwiKS4gSWYgeW91IHdpc2ggdG8gbW9jayBBUEkgcmVxdWVzdHMgb24gdGhpcyBwYWdlLCB5b3UgbXVzdCByZXNvbHZlIHRoaXMgc2NvcGUgaXNzdWUuXG5cbi0gKFJlY29tbWVuZGVkKSBSZWdpc3RlciB0aGUgd29ya2VyIGF0IHRoZSByb290IGxldmVsIChcIi9cIikgb2YgeW91ciBhcHBsaWNhdGlvbi5cbi0gU2V0IHRoZSBcIlNlcnZpY2UtV29ya2VyLUFsbG93ZWRcIiByZXNwb25zZSBoZWFkZXIgdG8gYWxsb3cgb3V0LW9mLXNjb3BlIHdvcmtlcnMuYFxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVN0YXJ0SGFuZGxlci50c1xudmFyIGNyZWF0ZVN0YXJ0SGFuZGxlciA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBzdGFydChvcHRpb25zLCBjdXN0b21PcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhcnRXb3JrZXJJbnN0YW5jZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnRleHQuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgY29udGV4dC53b3JrZXJDaGFubmVsLm9uKFxuICAgICAgICBcIlJFUVVFU1RcIixcbiAgICAgICAgY3JlYXRlUmVxdWVzdExpc3RlbmVyKGNvbnRleHQsIG9wdGlvbnMpXG4gICAgICApO1xuICAgICAgY29udGV4dC53b3JrZXJDaGFubmVsLm9uKFwiUkVTUE9OU0VcIiwgY3JlYXRlUmVzcG9uc2VMaXN0ZW5lcihjb250ZXh0KSk7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IGdldFdvcmtlckluc3RhbmNlKFxuICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIudXJsLFxuICAgICAgICBvcHRpb25zLnNlcnZpY2VXb3JrZXIub3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5maW5kV29ya2VyXG4gICAgICApO1xuICAgICAgY29uc3QgW3dvcmtlciwgcmVnaXN0cmF0aW9uXSA9IGluc3RhbmNlO1xuICAgICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1dvcmtlck1lc3NhZ2UgPSAoY3VzdG9tT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY3VzdG9tT3B0aW9ucy5maW5kV29ya2VyKSA/IGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgdGhlIFNlcnZpY2UgV29ya2VyIHJlZ2lzdHJhdGlvbiB1c2luZyBhIGN1c3RvbSBcImZpbmRXb3JrZXJcIiBwcmVkaWNhdGUuXG5cblBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgY3VzdG9tIHByZWRpY2F0ZSBwcm9wZXJseSBsb2NhdGVzIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gYXQgXCIlc1wiLlxuTW9yZSBkZXRhaWxzOiBodHRwczovL21zd2pzLmlvL2RvY3MvYXBpL3NldHVwLXdvcmtlci9zdGFydCNmaW5kd29ya2VyXG5gLFxuICAgICAgICAgIG9wdGlvbnMuc2VydmljZVdvcmtlci51cmxcbiAgICAgICAgKSA6IGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgdGhlIFNlcnZpY2UgV29ya2VyIHJlZ2lzdHJhdGlvbi5cblxuVGhpcyBtb3N0IGxpa2VseSBtZWFucyB0aGF0IHRoZSB3b3JrZXIgc2NyaXB0IFVSTCBcIiVzXCIgY2Fubm90IHJlc29sdmUgYWdhaW5zdCB0aGUgYWN0dWFsIHB1YmxpYyBob3N0bmFtZSAoJXMpLiBUaGlzIG1heSBoYXBwZW4gaWYgeW91ciBhcHBsaWNhdGlvbiBydW5zIGJlaGluZCBhIHByb3h5LCBvciBoYXMgYSBkeW5hbWljIGhvc3RuYW1lLlxuXG5QbGVhc2UgY29uc2lkZXIgdXNpbmcgYSBjdXN0b20gXCJzZXJ2aWNlV29ya2VyLnVybFwiIG9wdGlvbiB0byBwb2ludCB0byB0aGUgYWN0dWFsIHdvcmtlciBzY3JpcHQgbG9jYXRpb24sIG9yIGEgY3VzdG9tIFwiZmluZFdvcmtlclwiIG9wdGlvbiB0byByZXNvbHZlIHRoZSBTZXJ2aWNlIFdvcmtlciByZWdpc3RyYXRpb24gbWFudWFsbHkuIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9zZXR1cC13b3JrZXIvc3RhcnRgLFxuICAgICAgICAgIG9wdGlvbnMuc2VydmljZVdvcmtlci51cmwsXG4gICAgICAgICAgbG9jYXRpb24uaG9zdFxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWlzc2luZ1dvcmtlck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY29udGV4dC53b3JrZXIgPSB3b3JrZXI7XG4gICAgICBjb250ZXh0LnJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbjtcbiAgICAgIGNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKHdpbmRvdywgXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAod29ya2VyLnN0YXRlICE9PSBcInJlZHVuZGFudFwiKSB7XG4gICAgICAgICAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJDTElFTlRfQ0xPU0VEXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNvbnRleHQua2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBbaW50ZWdyaXR5RXJyb3JdID0gYXdhaXQgKDAsIGltcG9ydF91bnRpbDQudW50aWwpKFxuICAgICAgICAoKSA9PiByZXF1ZXN0SW50ZWdyaXR5Q2hlY2soY29udGV4dCwgd29ya2VyKVxuICAgICAgKTtcbiAgICAgIGlmIChpbnRlZ3JpdHlFcnJvcikge1xuICAgICAgICBkZXZVdGlscy5lcnJvcihgRGV0ZWN0ZWQgb3V0ZGF0ZWQgU2VydmljZSBXb3JrZXI6ICR7aW50ZWdyaXR5RXJyb3IubWVzc2FnZX1cblxuVGhlIG1vY2tpbmcgaXMgc3RpbGwgZW5hYmxlZCwgYnV0IGl0J3MgaGlnaGx5IHJlY29tbWVuZGVkIHRoYXQgeW91IHVwZGF0ZSB5b3VyIFNlcnZpY2UgV29ya2VyIGJ5IHJ1bm5pbmc6XG5cbiQgbnB4IG1zdyBpbml0IDxQVUJMSUNfRElSPlxuXG5UaGlzIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCB0aGUgU2VydmljZSBXb3JrZXIgaXMgaW4gc3luYyB3aXRoIHRoZSBsaWJyYXJ5IHRvIGd1YXJhbnRlZSBpdHMgc3RhYmlsaXR5LlxuSWYgdGhpcyBtZXNzYWdlIHN0aWxsIHBlcnNpc3RzIGFmdGVyIHVwZGF0aW5nLCBwbGVhc2UgcmVwb3J0IGFuIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi1kcmFmdC9tc3cvaXNzdWVzICAgICAgYCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmtlZXBBbGl2ZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKFxuICAgICAgICAoKSA9PiBjb250ZXh0LndvcmtlckNoYW5uZWwuc2VuZChcIktFRVBBTElWRV9SRVFVRVNUXCIpLFxuICAgICAgICA1ZTNcbiAgICAgICk7XG4gICAgICB2YWxpZGF0ZVdvcmtlclNjb3BlKHJlZ2lzdHJhdGlvbiwgY29udGV4dC5zdGFydE9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IHdvcmtlclJlZ2lzdHJhdGlvbiA9IHN0YXJ0V29ya2VySW5zdGFuY2UoKS50aGVuKFxuICAgICAgYXN5bmMgKHJlZ2lzdHJhdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBwZW5kaW5nSW5zdGFuY2UgPSByZWdpc3RyYXRpb24uaW5zdGFsbGluZyB8fCByZWdpc3RyYXRpb24ud2FpdGluZztcbiAgICAgICAgaWYgKHBlbmRpbmdJbnN0YW5jZSkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBwZW5kaW5nSW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJbnN0YW5jZS5zdGF0ZSA9PT0gXCJhY3RpdmF0ZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuYWJsZU1vY2tpbmcoY29udGV4dCwgb3B0aW9ucykuY2F0Y2goKGVycm9yMikgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVuYWJsZSBtb2NraW5nOiAke2Vycm9yMiA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVnaXN0cmF0aW9uO1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKG9wdGlvbnMud2FpdFVudGlsUmVhZHkpIHtcbiAgICAgIGRlZmVyTmV0d29ya1JlcXVlc3RzVW50aWwod29ya2VyUmVnaXN0cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlclJlZ2lzdHJhdGlvbjtcbiAgfTtcbn07XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdG9wL3V0aWxzL3ByaW50U3RvcE1lc3NhZ2UudHNcbmZ1bmN0aW9uIHByaW50U3RvcE1lc3NhZ2UoYXJncyA9IHt9KSB7XG4gIGlmIChhcmdzLnF1aWV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKFxuICAgIGAlYyR7ZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcIk1vY2tpbmcgZGlzYWJsZWQuXCIpfWAsXG4gICAgXCJjb2xvcjpvcmFuZ2VyZWQ7Zm9udC13ZWlnaHQ6Ym9sZDtcIlxuICApO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RvcC9jcmVhdGVTdG9wLnRzXG52YXIgY3JlYXRlU3RvcCA9IChjb250ZXh0KSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCkge1xuICAgICAgZGV2VXRpbHMud2FybihcbiAgICAgICAgJ0ZvdW5kIGEgcmVkdW5kYW50IFwid29ya2VyLnN0b3AoKVwiIGNhbGwuIE5vdGUgdGhhdCBzdG9wcGluZyB0aGUgd29ya2VyIHdoaWxlIG1vY2tpbmcgYWxyZWFkeSBzdG9wcGVkIGhhcyBubyBlZmZlY3QuIENvbnNpZGVyIHJlbW92aW5nIHRoaXMgXCJ3b3JrZXIuc3RvcCgpXCIgY2FsbC4nXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LndvcmtlckNoYW5uZWwuc2VuZChcIk1PQ0tfREVBQ1RJVkFURVwiKTtcbiAgICBjb250ZXh0LmlzTW9ja2luZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChjb250ZXh0LmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICBwcmludFN0b3BNZXNzYWdlKHsgcXVpZXQ6IChfYSA9IGNvbnRleHQuc3RhcnRPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVpZXQgfSk7XG4gIH07XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvcHJlcGFyZVN0YXJ0SGFuZGxlci50c1xudmFyIERFRkFVTFRfU1RBUlRfT1BUSU9OUyA9IHtcbiAgc2VydmljZVdvcmtlcjoge1xuICAgIHVybDogXCIvbW9ja1NlcnZpY2VXb3JrZXIuanNcIixcbiAgICBvcHRpb25zOiBudWxsXG4gIH0sXG4gIHF1aWV0OiBmYWxzZSxcbiAgd2FpdFVudGlsUmVhZHk6IHRydWUsXG4gIG9uVW5oYW5kbGVkUmVxdWVzdDogXCJ3YXJuXCIsXG4gIGZpbmRXb3JrZXIoc2NyaXB0VVJMLCBtb2NrU2VydmljZVdvcmtlclVybCkge1xuICAgIHJldHVybiBzY3JpcHRVUkwgPT09IG1vY2tTZXJ2aWNlV29ya2VyVXJsO1xuICB9XG59O1xuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlRmFsbGJhY2tSZXF1ZXN0TGlzdGVuZXIudHNcbnZhciBpbXBvcnRfaW50ZXJjZXB0b3JzMyA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzXCIpO1xudmFyIGltcG9ydF9mZXRjaDMgPSByZXF1aXJlKFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL2ZldGNoXCIpO1xudmFyIGltcG9ydF9YTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9pbnRlcmNlcHRvcnMvWE1MSHR0cFJlcXVlc3RcIik7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2NyZWF0ZVJlc3BvbnNlRnJvbUlzb21vcnBoaWNSZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VGcm9tSXNvbW9ycGhpY1Jlc3BvbnNlKHJlc3BvbnNlMikge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlMi5ib2R5LCB7XG4gICAgc3RhdHVzOiByZXNwb25zZTIuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMi5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHJlc3BvbnNlMi5oZWFkZXJzXG4gIH0pO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlRmFsbGJhY2tSZXF1ZXN0TGlzdGVuZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUZhbGxiYWNrUmVxdWVzdExpc3RlbmVyKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW50ZXJjZXB0b3IgPSBuZXcgaW1wb3J0X2ludGVyY2VwdG9yczMuQmF0Y2hJbnRlcmNlcHRvcih7XG4gICAgbmFtZTogXCJmYWxsYmFja1wiLFxuICAgIGludGVyY2VwdG9yczogW25ldyBpbXBvcnRfZmV0Y2gzLkZldGNoSW50ZXJjZXB0b3IoKSwgbmV3IGltcG9ydF9YTUxIdHRwUmVxdWVzdC5YTUxIdHRwUmVxdWVzdEludGVyY2VwdG9yKCldXG4gIH0pO1xuICBpbnRlcmNlcHRvci5vbihcInJlcXVlc3RcIiwgYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCBtb2NrZWRSZXF1ZXN0ID0gbmV3IE1vY2tlZFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKClcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBoYW5kbGVSZXF1ZXN0KFxuICAgICAgbW9ja2VkUmVxdWVzdCxcbiAgICAgIGNvbnRleHQucmVxdWVzdEhhbmRsZXJzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNvbnRleHQuZW1pdHRlcixcbiAgICAgIHtcbiAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2UzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMy5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UzLmhlYWRlcnMuYWxsKCksXG4gICAgICAgICAgICBib2R5OiByZXNwb25zZTMuYm9keSxcbiAgICAgICAgICAgIGRlbGF5OiByZXNwb25zZTMuZGVsYXlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvbk1vY2tlZFJlc3BvbnNlKF8sIHsgaGFuZGxlciwgcHVibGljUmVxdWVzdCwgcGFyc2VkUmVxdWVzdCB9KSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLnF1aWV0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIub25jZShcInJlc3BvbnNlOm1vY2tlZFwiLCBhc3luYyAocmVzcG9uc2UzKSA9PiB7XG4gICAgICAgICAgICAgIGhhbmRsZXIubG9nKFxuICAgICAgICAgICAgICAgIHB1YmxpY1JlcXVlc3QsXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VyaWFsaXplUmVzcG9uc2UocmVzcG9uc2UzKSxcbiAgICAgICAgICAgICAgICBwYXJzZWRSZXF1ZXN0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChyZXNwb25zZTIpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uZFdpdGgocmVzcG9uc2UyKTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcmNlcHRvci5vbihcInJlc3BvbnNlXCIsIChyZXF1ZXN0LCByZXNwb25zZTIpID0+IHtcbiAgICBpZiAoIXJlcXVlc3QuaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnJvd3NlclJlc3BvbnNlID0gY3JlYXRlUmVzcG9uc2VGcm9tSXNvbW9ycGhpY1Jlc3BvbnNlKHJlc3BvbnNlMik7XG4gICAgaWYgKHJlc3BvbnNlMi5oZWFkZXJzLmdldChcIngtcG93ZXJlZC1ieVwiKSA9PT0gXCJtc3dcIikge1xuICAgICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTptb2NrZWRcIiwgYnJvd3NlclJlc3BvbnNlLCByZXF1ZXN0LmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTpieXBhc3NcIiwgYnJvd3NlclJlc3BvbnNlLCByZXF1ZXN0LmlkKTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcmNlcHRvci5hcHBseSgpO1xuICByZXR1cm4gaW50ZXJjZXB0b3I7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVGYWxsYmFja1N0YXJ0LnRzXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1N0YXJ0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICBjb250ZXh0LmZhbGxiYWNrSW50ZXJjZXB0b3IgPSBjcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lcihcbiAgICAgIGNvbnRleHQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBwcmludFN0YXJ0TWVzc2FnZSh7XG4gICAgICBtZXNzYWdlOiBcIk1vY2tpbmcgZW5hYmxlZCAoZmFsbGJhY2sgbW9kZSkuXCIsXG4gICAgICBxdWlldDogb3B0aW9ucy5xdWlldFxuICAgIH0pO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH07XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdG9wL2NyZWF0ZUZhbGxiYWNrU3RvcC50c1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tTdG9wKGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2EgPSBjb250ZXh0LmZhbGxiYWNrSW50ZXJjZXB0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgcHJpbnRTdG9wTWVzc2FnZSh7IHF1aWV0OiAoX2IgPSBjb250ZXh0LnN0YXJ0T3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnF1aWV0IH0pO1xuICB9O1xufVxuXG4vLyBzcmMvU2V0dXBBcGkudHNcbnZhciBpbXBvcnRfb3V0dmFyaWFudDQgPSByZXF1aXJlKFwib3V0dmFyaWFudFwiKTtcbnZhciBpbXBvcnRfc3RyaWN0X2V2ZW50X2VtaXR0ZXIgPSByZXF1aXJlKFwic3RyaWN0LWV2ZW50LWVtaXR0ZXJcIik7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9waXBlRXZlbnRzLnRzXG5mdW5jdGlvbiBwaXBlRXZlbnRzKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3QgcmF3RW1pdCA9IHNvdXJjZS5lbWl0O1xuICBpZiAocmF3RW1pdC5faXNQaXBlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBzb3VyY2UuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCAuLi5kYXRhMikge1xuICAgIGRlc3RpbmF0aW9uLmVtaXQoZXZlbnQsIC4uLmRhdGEyKTtcbiAgICByZXR1cm4gcmF3RW1pdC5jYWxsKHRoaXMsIGV2ZW50LCAuLi5kYXRhMik7XG4gIH07XG4gIHNvdXJjZS5lbWl0Ll9pc1BpcGVkID0gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3RvUmVhZG9ubHlBcnJheS50c1xuZnVuY3Rpb24gdG9SZWFkb25seUFycmF5KHNvdXJjZSkge1xuICBjb25zdCBjbG9uZSA9IFsuLi5zb3VyY2VdO1xuICBPYmplY3QuZnJlZXplKGNsb25lKTtcbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vLyBzcmMvU2V0dXBBcGkudHNcbnZhciBTZXR1cEFwaSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uaW5pdGlhbEhhbmRsZXJzKSB7XG4gICAgdGhpcy52YWxpZGF0ZUhhbmRsZXJzKC4uLmluaXRpYWxIYW5kbGVycyk7XG4gICAgdGhpcy5pbml0aWFsSGFuZGxlcnMgPSB0b1JlYWRvbmx5QXJyYXkoaW5pdGlhbEhhbmRsZXJzKTtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycyA9IFsuLi5pbml0aWFsSGFuZGxlcnNdO1xuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBpbXBvcnRfc3RyaWN0X2V2ZW50X2VtaXR0ZXIuRW1pdHRlcigpO1xuICAgIHRoaXMucHVibGljRW1pdHRlciA9IG5ldyBpbXBvcnRfc3RyaWN0X2V2ZW50X2VtaXR0ZXIuRW1pdHRlcigpO1xuICAgIHBpcGVFdmVudHModGhpcy5lbWl0dGVyLCB0aGlzLnB1YmxpY0VtaXR0ZXIpO1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5jcmVhdGVMaWZlQ3ljbGVFdmVudHMoKTtcbiAgfVxuICB2YWxpZGF0ZUhhbmRsZXJzKC4uLmhhbmRsZXJzKSB7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAoMCwgaW1wb3J0X291dHZhcmlhbnQ0LmludmFyaWFudCkoXG4gICAgICAgICFBcnJheS5pc0FycmF5KGhhbmRsZXIpLFxuICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICdGYWlsZWQgdG8gY29uc3RydWN0IFwiJXNcIiBnaXZlbiBhbiBBcnJheSBvZiByZXF1ZXN0IGhhbmRsZXJzLiBNYWtlIHN1cmUgeW91IHNwcmVhZCB0aGUgcmVxdWVzdCBoYW5kbGVycyB3aGVuIGNhbGxpbmcgdGhlIHJlc3BlY3RpdmUgc2V0dXAgZnVuY3Rpb24uJ1xuICAgICAgICApLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMucHVibGljRW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuICB1c2UoLi4ucnVudGltZUhhbmRsZXJzKSB7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMudW5zaGlmdCguLi5ydW50aW1lSGFuZGxlcnMpO1xuICB9XG4gIHJlc3RvcmVIYW5kbGVycygpIHtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICBoYW5kbGVyLm1hcmtBc1NraXBwZWQoZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0SGFuZGxlcnMoLi4ubmV4dEhhbmRsZXJzKSB7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMgPSBuZXh0SGFuZGxlcnMubGVuZ3RoID4gMCA/IFsuLi5uZXh0SGFuZGxlcnNdIDogWy4uLnRoaXMuaW5pdGlhbEhhbmRsZXJzXTtcbiAgfVxuICBsaXN0SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHRvUmVhZG9ubHlBcnJheSh0aGlzLmN1cnJlbnRIYW5kbGVycyk7XG4gIH1cbiAgY3JlYXRlTGlmZUN5Y2xlRXZlbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljRW1pdHRlci5vbiguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVMaXN0ZW5lcjogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljRW1pdHRlci5yZW1vdmVMaXN0ZW5lciguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zZXR1cFdvcmtlci50c1xudmFyIFNldHVwV29ya2VyQXBpID0gY2xhc3MgZXh0ZW5kcyBTZXR1cEFwaSB7XG4gIGNvbnN0cnVjdG9yKC4uLmhhbmRsZXJzKSB7XG4gICAgc3VwZXIoLi4uaGFuZGxlcnMpO1xuICAgIHRoaXMuc3RhcnRIYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLnN0b3BIYW5kbGVyID0gbnVsbDtcbiAgICAoMCwgaW1wb3J0X291dHZhcmlhbnQ1LmludmFyaWFudCkoXG4gICAgICAhKDAsIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MzLmlzTm9kZVByb2Nlc3MpKCksXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlIGBzZXR1cFdvcmtlcmAgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gQ29uc2lkZXIgdXNpbmcgYHNldHVwU2VydmVyYCBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudCBpbnN0ZWFkLlwiXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY3JlYXRlV29ya2VyQ29udGV4dCgpO1xuICB9XG4gIGNyZWF0ZVdvcmtlckNvbnRleHQoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGlzTW9ja2luZ0VuYWJsZWQ6IGZhbHNlLFxuICAgICAgc3RhcnRPcHRpb25zOiBudWxsLFxuICAgICAgd29ya2VyOiBudWxsLFxuICAgICAgcmVnaXN0cmF0aW9uOiBudWxsLFxuICAgICAgcmVxdWVzdEhhbmRsZXJzOiB0aGlzLmN1cnJlbnRIYW5kbGVycyxcbiAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgIHdvcmtlckNoYW5uZWw6IHtcbiAgICAgICAgb246IChldmVudFR5cGUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmV2ZW50cy5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLFxuICAgICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gdGhpcy5jb250ZXh0Lndvcmtlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmQ6ICh0eXBlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIChfYSA9IHRoaXMuY29udGV4dC53b3JrZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wb3N0TWVzc2FnZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBhZGRMaXN0ZW5lcjogKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goeyBldmVudFR5cGUsIHRhcmdldCwgY2FsbGJhY2sgfSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2sgfSBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2U6IChldmVudFR5cGUpID0+IHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVJbmNvbWluZ01lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIsXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgaGFuZGxlSW5jb21pbmdNZXNzYWdlXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIsXG4gICAgICAgICAgICAgICAgXCJtZXNzYWdlZXJyb3JcIixcbiAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGJpbmRpbmdzLmZvckVhY2goKHVuYmluZCkgPT4gdW5iaW5kKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRmFsbGJhY2tNb2RlOiAhKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikgfHwgbG9jYXRpb24ucHJvdG9jb2wgPT09IFwiZmlsZTpcIlxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29udGV4dCwge1xuICAgICAgcmVxdWVzdEhhbmRsZXJzOiB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy5jdXJyZW50SGFuZGxlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXJ0SGFuZGxlciA9IGNvbnRleHQudXNlRmFsbGJhY2tNb2RlID8gY3JlYXRlRmFsbGJhY2tTdGFydChjb250ZXh0KSA6IGNyZWF0ZVN0YXJ0SGFuZGxlcihjb250ZXh0KTtcbiAgICB0aGlzLnN0b3BIYW5kbGVyID0gY29udGV4dC51c2VGYWxsYmFja01vZGUgPyBjcmVhdGVGYWxsYmFja1N0b3AoY29udGV4dCkgOiBjcmVhdGVTdG9wKGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIGFzeW5jIHN0YXJ0KG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuY29udGV4dC5zdGFydE9wdGlvbnMgPSBtZXJnZVJpZ2h0KFxuICAgICAgREVGQVVMVF9TVEFSVF9PUFRJT05TLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RhcnRIYW5kbGVyKHRoaXMuY29udGV4dC5zdGFydE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIHByaW50SGFuZGxlcnMoKSB7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmxpc3RIYW5kbGVycygpO1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgIGNvbnN0IHsgaGVhZGVyLCBjYWxsRnJhbWUgfSA9IGhhbmRsZXIuaW5mbztcbiAgICAgIGNvbnN0IHByYWdtYSA9IGhhbmRsZXIuaW5mby5oYXNPd25Qcm9wZXJ0eShcIm9wZXJhdGlvblR5cGVcIikgPyBcIltncmFwaHFsXVwiIDogXCJbcmVzdF1cIjtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYCR7cHJhZ21hfSAke2hlYWRlcn1gKTtcbiAgICAgIGlmIChjYWxsRnJhbWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYERlY2xhcmF0aW9uOiAke2NhbGxGcmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKFwiSGFuZGxlcjpcIiwgaGFuZGxlcik7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5jb250ZXh0LmV2ZW50cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNvbnRleHQuZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0b3BIYW5kbGVyKCk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXR1cFdvcmtlciguLi5oYW5kbGVycykge1xuICByZXR1cm4gbmV3IFNldHVwV29ya2VyQXBpKC4uLmhhbmRsZXJzKTtcbn1cblxuLy8gc3JjL3Jlc3QudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc3RIYW5kbGVyKG1ldGhvZCkge1xuICByZXR1cm4gKHBhdGgsIHJlc29sdmVyKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBSZXN0SGFuZGxlcihtZXRob2QsIHBhdGgsIHJlc29sdmVyKTtcbiAgfTtcbn1cbnZhciByZXN0ID0ge1xuICBhbGw6IGNyZWF0ZVJlc3RIYW5kbGVyKC8uKy8pLFxuICBoZWFkOiBjcmVhdGVSZXN0SGFuZGxlcihcIkhFQURcIiAvKiBIRUFEICovKSxcbiAgZ2V0OiBjcmVhdGVSZXN0SGFuZGxlcihcIkdFVFwiIC8qIEdFVCAqLyksXG4gIHBvc3Q6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiUE9TVFwiIC8qIFBPU1QgKi8pLFxuICBwdXQ6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiUFVUXCIgLyogUFVUICovKSxcbiAgZGVsZXRlOiBjcmVhdGVSZXN0SGFuZGxlcihcIkRFTEVURVwiIC8qIERFTEVURSAqLyksXG4gIHBhdGNoOiBjcmVhdGVSZXN0SGFuZGxlcihcIlBBVENIXCIgLyogUEFUQ0ggKi8pLFxuICBvcHRpb25zOiBjcmVhdGVSZXN0SGFuZGxlcihcIk9QVElPTlNcIiAvKiBPUFRJT05TICovKVxufTtcblxuLy8gc3JjL2dyYXBocWwudHNcbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlZEdyYXBoUUxIYW5kbGVyKG9wZXJhdGlvblR5cGUsIHVybCkge1xuICByZXR1cm4gKG9wZXJhdGlvbk5hbWUsIHJlc29sdmVyKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBHcmFwaFFMSGFuZGxlcihcbiAgICAgIG9wZXJhdGlvblR5cGUsXG4gICAgICBvcGVyYXRpb25OYW1lLFxuICAgICAgdXJsLFxuICAgICAgcmVzb2x2ZXJcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR3JhcGhRTE9wZXJhdGlvbkhhbmRsZXIodXJsKSB7XG4gIHJldHVybiAocmVzb2x2ZXIpID0+IHtcbiAgICByZXR1cm4gbmV3IEdyYXBoUUxIYW5kbGVyKFxuICAgICAgXCJhbGxcIixcbiAgICAgIG5ldyBSZWdFeHAoXCIuKlwiKSxcbiAgICAgIHVybCxcbiAgICAgIHJlc29sdmVyXG4gICAgKTtcbiAgfTtcbn1cbnZhciBzdGFuZGFyZEdyYXBoUUxIYW5kbGVycyA9IHtcbiAgb3BlcmF0aW9uOiBjcmVhdGVHcmFwaFFMT3BlcmF0aW9uSGFuZGxlcihcIipcIiksXG4gIHF1ZXJ5OiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihcInF1ZXJ5XCIsIFwiKlwiKSxcbiAgbXV0YXRpb246IGNyZWF0ZVNjb3BlZEdyYXBoUUxIYW5kbGVyKFwibXV0YXRpb25cIiwgXCIqXCIpXG59O1xuZnVuY3Rpb24gY3JlYXRlR3JhcGhRTExpbmsodXJsKSB7XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uOiBjcmVhdGVHcmFwaFFMT3BlcmF0aW9uSGFuZGxlcih1cmwpLFxuICAgIHF1ZXJ5OiBjcmVhdGVTY29wZWRHcmFwaFFMSGFuZGxlcihcInF1ZXJ5XCIsIHVybCksXG4gICAgbXV0YXRpb246IGNyZWF0ZVNjb3BlZEdyYXBoUUxIYW5kbGVyKFwibXV0YXRpb25cIiwgdXJsKVxuICB9O1xufVxudmFyIGdyYXBocWwgPSB7XG4gIC4uLnN0YW5kYXJkR3JhcGhRTEhhbmRsZXJzLFxuICBsaW5rOiBjcmVhdGVHcmFwaFFMTGlua1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG5jaGVja0dsb2JhbHMoKTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBHcmFwaFFMSGFuZGxlcixcbiAgTW9ja2VkUmVxdWVzdCxcbiAgUkVTVE1ldGhvZHMsXG4gIFJlcXVlc3RIYW5kbGVyLFxuICBSZXN0SGFuZGxlcixcbiAgU2V0dXBBcGksXG4gIFNldHVwV29ya2VyQXBpLFxuICBjbGVhblVybCxcbiAgY29tcG9zZSxcbiAgY29udGV4dCxcbiAgY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbixcbiAgZGVmYXVsdENvbnRleHQsXG4gIGRlZmF1bHRSZXNwb25zZSxcbiAgZ3JhcGhxbCxcbiAgZ3JhcGhxbENvbnRleHQsXG4gIGhhbmRsZVJlcXVlc3QsXG4gIG1hdGNoUmVxdWVzdFVybCxcbiAgcmVzcG9uc2UsXG4gIHJlc3QsXG4gIHJlc3RDb250ZXh0LFxuICBzZXR1cFdvcmtlclxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/Emitter.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/msw/node_modules/strict-event-emitter/lib/Emitter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Emitter = void 0;\nconst MemoryLeakError_1 = __webpack_require__(/*! ./MemoryLeakError */ \"(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/MemoryLeakError.js\");\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nclass Emitter {\n    constructor() {\n        this.events = new Map();\n        this.maxListeners = Emitter.defaultMaxListeners;\n        this.hasWarnedAboutPotentialMemoryLeak = false;\n    }\n    static listenerCount(emitter, eventName) {\n        return emitter.listenerCount(eventName);\n    }\n    _emitInternalEvent(internalEventName, eventName, listener) {\n        this.emit(internalEventName, \n        // Anything to make TypeScript happy.\n        ...[eventName, listener]);\n    }\n    _getListeners(eventName) {\n        return this.events.get(eventName) || [];\n    }\n    _removeListener(listeners, listener) {\n        const index = listeners.indexOf(listener);\n        if (index > -1) {\n            listeners.splice(index, 1);\n        }\n        return [];\n    }\n    _wrapOnceListener(eventName, listener) {\n        const onceListener = (...data) => {\n            this.removeListener(eventName, onceListener);\n            listener.apply(this, data);\n        };\n        return onceListener;\n    }\n    setMaxListeners(maxListeners) {\n        this.maxListeners = maxListeners;\n        return this;\n    }\n    /**\n     * Returns the current max listener value for the `Emitter` which is\n     * either set by `emitter.setMaxListeners(n)` or defaults to\n     * `Emitter.defaultMaxListeners`.\n     */\n    getMaxListeners() {\n        return this.maxListeners;\n    }\n    /**\n     * Returns an array listing the events for which the emitter has registered listeners.\n     * The values in the array will be strings or Symbols.\n     */\n    eventNames() {\n        return Array.from(this.events.keys());\n    }\n    /**\n     * Synchronously calls each of the listeners registered for the event named `eventName`,\n     * in the order they were registered, passing the supplied arguments to each.\n     * Returns `true` if the event has listeners, `false` otherwise.\n     *\n     * @example\n     * const emitter = new Emitter<{ hello: [string] }>()\n     * emitter.emit('hello', 'John')\n     */\n    emit(eventName, ...data) {\n        const listeners = this._getListeners(eventName);\n        listeners.forEach((listener) => {\n            listener.apply(this, data);\n        });\n        return listeners.length > 0;\n    }\n    addListener(eventName, listener) {\n        // Emit the `newListener` event before adding the listener.\n        this._emitInternalEvent('newListener', eventName, listener);\n        const nextListeners = this._getListeners(eventName).concat(listener);\n        this.events.set(eventName, nextListeners);\n        if (this.maxListeners > 0 &&\n            this.listenerCount(eventName) > this.maxListeners &&\n            !this.hasWarnedAboutPotentialMemoryLeak) {\n            this.hasWarnedAboutPotentialMemoryLeak = true;\n            const memoryLeakWarning = new MemoryLeakError_1.MemoryLeakError(this, eventName, this.listenerCount(eventName));\n            console.warn(memoryLeakWarning);\n        }\n        return this;\n    }\n    on(eventName, listener) {\n        return this.addListener(eventName, listener);\n    }\n    once(eventName, listener) {\n        return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n    }\n    prependListener(eventName, listener) {\n        const listeners = this._getListeners(eventName);\n        if (listeners.length > 0) {\n            const nextListeners = [listener].concat(listeners);\n            this.events.set(eventName, nextListeners);\n        }\n        else {\n            this.events.set(eventName, listeners.concat(listener));\n        }\n        return this;\n    }\n    prependOnceListener(eventName, listener) {\n        return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n    }\n    removeListener(eventName, listener) {\n        const listeners = this._getListeners(eventName);\n        if (listeners.length > 0) {\n            this._removeListener(listeners, listener);\n            this.events.set(eventName, listeners);\n            // Emit the `removeListener` event after removing the listener.\n            this._emitInternalEvent('removeListener', eventName, listener);\n        }\n        return this;\n    }\n    /**\n     * Alias for `emitter.removeListener()`.\n     *\n     * @example\n     * emitter.off('hello', listener)\n     */\n    off(eventName, listener) {\n        return this.removeListener(eventName, listener);\n    }\n    removeAllListeners(eventName) {\n        if (eventName) {\n            this.events.delete(eventName);\n        }\n        else {\n            this.events.clear();\n        }\n        return this;\n    }\n    /**\n     * Returns a copy of the array of listeners for the event named `eventName`.\n     */\n    listeners(eventName) {\n        return Array.from(this._getListeners(eventName));\n    }\n    /**\n     * Returns the number of listeners listening to the event named `eventName`.\n     */\n    listenerCount(eventName) {\n        return this._getListeners(eventName).length;\n    }\n    rawListeners(eventName) {\n        return this.listeners(eventName);\n    }\n}\nexports.Emitter = Emitter;\nEmitter.defaultMaxListeners = 10;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9ub2RlX21vZHVsZXMvc3RyaWN0LWV2ZW50LWVtaXR0ZXIvbGliL0VtaXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLDBCQUEwQixtQkFBTyxDQUFDLGdIQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxpb3NoYXNoLXdlYi8uLi8uLi9ub2RlX21vZHVsZXMvbXN3L25vZGVfbW9kdWxlcy9zdHJpY3QtZXZlbnQtZW1pdHRlci9saWIvRW1pdHRlci5qcz9lMTkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWl0dGVyID0gdm9pZCAwO1xuY29uc3QgTWVtb3J5TGVha0Vycm9yXzEgPSByZXF1aXJlKFwiLi9NZW1vcnlMZWFrRXJyb3JcIik7XG4vKipcbiAqIE5vZGUuanMtY29tcGF0aWJsZSBpbXBsZW1lbnRhdGlvbiBvZiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyPHsgaGVsbG86IFtzdHJpbmddIH0+KClcbiAqIGVtaXR0ZXIub24oJ2hlbGxvJywgKG5hbWUpID0+IGNvbnNvbGUubG9nKG5hbWUpKVxuICogZW1pdHRlci5lbWl0KCdoZWxsbycsICdKb2huJylcbiAqL1xuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1heExpc3RlbmVycyA9IEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICAgICAgdGhpcy5oYXNXYXJuZWRBYm91dFBvdGVudGlhbE1lbW9yeUxlYWsgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGxpc3RlbmVyQ291bnQoZW1pdHRlciwgZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcbiAgICB9XG4gICAgX2VtaXRJbnRlcm5hbEV2ZW50KGludGVybmFsRXZlbnROYW1lLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdChpbnRlcm5hbEV2ZW50TmFtZSwgXG4gICAgICAgIC8vIEFueXRoaW5nIHRvIG1ha2UgVHlwZVNjcmlwdCBoYXBweS5cbiAgICAgICAgLi4uW2V2ZW50TmFtZSwgbGlzdGVuZXJdKTtcbiAgICB9XG4gICAgX2dldExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpIHx8IFtdO1xuICAgIH1cbiAgICBfcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgX3dyYXBPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBvbmNlTGlzdGVuZXIgPSAoLi4uZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9uY2VMaXN0ZW5lcjtcbiAgICB9XG4gICAgc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycykge1xuICAgICAgICB0aGlzLm1heExpc3RlbmVycyA9IG1heExpc3RlbmVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWF4IGxpc3RlbmVyIHZhbHVlIGZvciB0aGUgYEVtaXR0ZXJgIHdoaWNoIGlzXG4gICAgICogZWl0aGVyIHNldCBieSBgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMobilgIG9yIGRlZmF1bHRzIHRvXG4gICAgICogYEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVyc2AuXG4gICAgICovXG4gICAgZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhMaXN0ZW5lcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gICAgICogVGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgd2lsbCBiZSBzdHJpbmdzIG9yIFN5bWJvbHMuXG4gICAgICovXG4gICAgZXZlbnROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5ldmVudHMua2V5cygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSBjYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgdGhlIGV2ZW50IG5hbWVkIGBldmVudE5hbWVgLFxuICAgICAqIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVnaXN0ZXJlZCwgcGFzc2luZyB0aGUgc3VwcGxpZWQgYXJndW1lbnRzIHRvIGVhY2guXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhcyBsaXN0ZW5lcnMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXI8eyBoZWxsbzogW3N0cmluZ10gfT4oKVxuICAgICAqIGVtaXR0ZXIuZW1pdCgnaGVsbG8nLCAnSm9obicpXG4gICAgICovXG4gICAgZW1pdChldmVudE5hbWUsIC4uLmRhdGEpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gRW1pdCB0aGUgYG5ld0xpc3RlbmVyYCBldmVudCBiZWZvcmUgYWRkaW5nIHRoZSBsaXN0ZW5lci5cbiAgICAgICAgdGhpcy5fZW1pdEludGVybmFsRXZlbnQoJ25ld0xpc3RlbmVyJywgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIGNvbnN0IG5leHRMaXN0ZW5lcnMgPSB0aGlzLl9nZXRMaXN0ZW5lcnMoZXZlbnROYW1lKS5jb25jYXQobGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnROYW1lLCBuZXh0TGlzdGVuZXJzKTtcbiAgICAgICAgaWYgKHRoaXMubWF4TGlzdGVuZXJzID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkgPiB0aGlzLm1heExpc3RlbmVycyAmJlxuICAgICAgICAgICAgIXRoaXMuaGFzV2FybmVkQWJvdXRQb3RlbnRpYWxNZW1vcnlMZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dhcm5lZEFib3V0UG90ZW50aWFsTWVtb3J5TGVhayA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBtZW1vcnlMZWFrV2FybmluZyA9IG5ldyBNZW1vcnlMZWFrRXJyb3JfMS5NZW1vcnlMZWFrRXJyb3IodGhpcywgZXZlbnROYW1lLCB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVtb3J5TGVha1dhcm5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLl93cmFwT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgcHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dExpc3RlbmVycyA9IFtsaXN0ZW5lcl0uY29uY2F0KGxpc3RlbmVycyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnROYW1lLCBuZXh0TGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudE5hbWUsIGxpc3RlbmVycy5jb25jYXQobGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMuX3dyYXBPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2dldExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50TmFtZSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgIC8vIEVtaXQgdGhlIGByZW1vdmVMaXN0ZW5lcmAgZXZlbnQgYWZ0ZXIgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyLlxuICAgICAgICAgICAgdGhpcy5fZW1pdEludGVybmFsRXZlbnQoJ3JlbW92ZUxpc3RlbmVyJywgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcigpYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZW1pdHRlci5vZmYoJ2hlbGxvJywgbGlzdGVuZXIpXG4gICAgICovXG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgbmFtZWQgYGV2ZW50TmFtZWAuXG4gICAgICovXG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9nZXRMaXN0ZW5lcnMoZXZlbnROYW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIHRoZSBldmVudCBuYW1lZCBgZXZlbnROYW1lYC5cbiAgICAgKi9cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50TmFtZSkubGVuZ3RoO1xuICAgIH1cbiAgICByYXdMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG5FbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/Emitter.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/MemoryLeakError.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/msw/node_modules/strict-event-emitter/lib/MemoryLeakError.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MemoryLeakError = void 0;\nclass MemoryLeakError extends Error {\n    constructor(emitter, type, count) {\n        super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n        this.emitter = emitter;\n        this.type = type;\n        this.count = count;\n        this.name = 'MaxListenersExceededWarning';\n    }\n}\nexports.MemoryLeakError = MemoryLeakError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9ub2RlX21vZHVsZXMvc3RyaWN0LWV2ZW50LWVtaXR0ZXIvbGliL01lbW9yeUxlYWtFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDZEQUE2RCxPQUFPLEVBQUUsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGlvc2hhc2gtd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9tc3cvbm9kZV9tb2R1bGVzL3N0cmljdC1ldmVudC1lbWl0dGVyL2xpYi9NZW1vcnlMZWFrRXJyb3IuanM/ODYwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVtb3J5TGVha0Vycm9yID0gdm9pZCAwO1xuY2xhc3MgTWVtb3J5TGVha0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIHR5cGUsIGNvdW50KSB7XG4gICAgICAgIHN1cGVyKGBQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICR7Y291bnR9ICR7dHlwZS50b1N0cmluZygpfSBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0YCk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgfVxufVxuZXhwb3J0cy5NZW1vcnlMZWFrRXJyb3IgPSBNZW1vcnlMZWFrRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/MemoryLeakError.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/index.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/msw/node_modules/strict-event-emitter/lib/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./Emitter */ \"(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/Emitter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MemoryLeakError */ \"(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/MemoryLeakError.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9ub2RlX21vZHVsZXMvc3RyaWN0LWV2ZW50LWVtaXR0ZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnR0FBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsZ0hBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsaW9zaGFzaC13ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL21zdy9ub2RlX21vZHVsZXMvc3RyaWN0LWV2ZW50LWVtaXR0ZXIvbGliL2luZGV4LmpzP2EyNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FbWl0dGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9NZW1vcnlMZWFrRXJyb3JcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/msw/node_modules/strict-event-emitter/lib/index.js\n");

/***/ })

};
;